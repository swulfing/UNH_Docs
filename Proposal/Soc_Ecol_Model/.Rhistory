for(i in 1:nrow(param_tests)){
pl[[i]] <- paramplane(param_tests$firstParam[i], param_tests$secondParam[i], 1, 1)
}
do.call("grid.arrange", c(pl,  ncol=2))
}
#grid.expand stuff
ode(
func=Bauch.Coupled,
y=xstart,
times=times,
parms=params_Bauch
) %>%
as.data.frame() -> out_Diff
#
params_Bauch <- c(r_1 = params_Default$r_1, s_1 = params_Default$s_1, h_1 = params_Default$h_1, k_1 = params_Default$k_1,
w_1 = params_Default$w_1, c_1 = params_Default$c_1, d_1 = params_Default$d_1, i_1 = params_Default$i_1,
rho_1 =  params_Default$rho_1,
r_2 = params_Default$r_2, s_2 = params_Default$s_2, h_2 = params_Default$h_2, k_2 = params_Default$k_2,
w_2 = params_Default$w_2, c_2 = params_Default$c_2, d_2 = params_Default$d_2, i_2 = params_Default$i_2,
rho_2 = params_Default$rho_2)
ode(
func=Bauch.Coupled,
y=xstart,
times=times,
parms=params_Bauch
) %>%
as.data.frame() -> out_Diff
paramplane_testing(1)
paramplane_testing(2)
knitr::opts_chunk$set(echo = FALSE, warning = FALSE, message = FALSE)
setwd("C:/Users/sophi/Documents/GitHub/UNH_Docs/Proposal/Soc_Ecol_Model")
library(deSolve)
library(tidyverse)
library(ggplot2)
library(gridExtra)
library(kableExtra)
#params_set <- data.frame( R   = 0.07, s   = 0.8, h   = 0.1, k   = 1.014, w   = 0.35, c   = 1.5, d   = 0.5, e   = 0.5, i   = 0.5, prop   = 0.5)
params_list <-  data.frame(r_1 = 0.35, s_1 = 0.8, h_1 = 0.5, k_1 = 1.014, w_1 = 0.35, c_1 = 1.5, d_1 = 0.5, i_1 = 0.2, rho_1 = 0.5,
r_2 = 0.35, s_2 = 0.8, h_2 = 0.5, k_2 = 1.014, w_2 = 0.35, c_2 = 1.5, d_2 = 0.5, i_2 = 0.2, rho_2 = 0.5)
xstart <- c(F_1 = 0.406, F_2 = 0.406, X_1 = .24, X_2 = .24)
timespan <- seq(from = 0, to = 100, by = .1)
##Maybe see what proportion of people can actually be fishing in this system to make it sustainable
Bauch.Coupled <- function (t, y, params) {
## first extract the state variables
F_1 <- y[1] #Fish Pop var
F_2 <- y[2] #Fish Pop var
X_1 <- y[3] #conservationist var
X_2 <- y[4] #conservationist var
#TT <- y[5]
## now extract the parameters
r_1 <- params["r_1"] # Net growth/fecundity
s_1 <- params["s_1"] # supply and demand
h_1 <- params["h_1"] # Harvesting efficiency
k_1 <- params["k_1"] # Social learning rate
w_1 <- params["w_1"] # conservation costs
c_1 <- params["c_1"] # rarity valuation param
d_1 <- params["d_1"] # social norm strength
r_2 <- params["r_2"] # Net growth/fecundity
s_2 <- params["s_2"] # supply and demand
h_2 <- params["h_2"] # Harvesting efficiency
k_2 <- params["k_2"] # Social learning rate
w_2 <- params["w_2"] # conservation costs
c_2 <- params["c_2"] # rarity valuation param
d_2 <- params["d_2"] # social norm strength
i_1 <- params["i_1"] # Inflow of fish from pop 2 to pop 1
i_2 <- params["i_2"] # Inflow of fish from pop 1 to pop 2
rho_1 <- params["rho_1"] # Influence of pop 2 on pop 1
rho_2 <- params["rho_2"] # Influence of pop 1 on pop 2
## now code the model equations
dF_1dt <-  r_1 * F_1 * (1-F_1) - (h_1 * F_1 * (1-X_1))/(F_1+s_1) - i_2 * F_1 + i_1 * F_2
dF_2dt <-  r_2 * F_2 * (1-F_2) - (h_2 * F_2 * (1-X_2))/(F_2+s_2) - i_1 * F_2 + i_2 * F_1
dX_1dt <- k_1 * X_1 * (1-X_1) *(1/(F_1 + c_1) - w_1 + d_1*(2*X_1 - 1) + rho_1 * (2*X_2 - 1))
dX_2dt <- k_2 * X_2 * (1-X_2) *(1/(F_2 + c_2) - w_2 + d_2*(2*X_2 - 1) + rho_2 * (2*X_1 - 1))
## combine results into a single vector
dydt <- c(dF_1dt, dF_2dt, dX_1dt, dX_2dt)
## return result as a list!
list(dydt)
}
params_Bauch2 <- params_list
times <- timespan
xstart <- c(F_1 = 0.406, F_2 = 0.406, X_1 = .24, X_2 = .24)
ode(
func=Bauch.Coupled,
y=xstart,
times=times,
parms=params_Bauch2
) %>%
as.data.frame() -> out_Coupled
out_Coupled %>%
gather(variable,value,-time) %>%
ggplot(aes(x=time,y=value,color=variable))+
geom_line(size=1)+
theme_classic()+
labs(x='time (yr)',y='pop')
# paramx <- 1
# paramy <- 2
# maxx <- 1
# maxy <- 1
# i <- 1
paramplane <- function(paramx, paramy, maxx, maxy){
#Create empty dataframe to fill
paramlist <- c("r", "s", "h", "k", "w", "c", "d", "i", "rho")
outcomes <- data.frame(matrix(ncol = 4, nrow = 0))
colnames(outcomes) <- c("XParameter", "YParameter", "Fish1", "Fish2")
#Dumb but it throws an error if S = 0
startx <- 0
starty <- 0
if(paramx == 2){startx <- .001}
if(paramy == 2){starty <- .001}
#
# #Can comment this part out if using other H vals
# if(paramx == 3){maxx = 0.1}
# if(paramy == 3){maxy = 0.1}
#Create list of all combinations of the two paramters
paramcombos <- expand.grid(x_parameter = seq(from = startx, to = maxx, length.out = 11),
y_parameter = seq(from = starty, to = maxy, length.out = 11))
for(i in 1:nrow(paramcombos)){
params_Default <- params_list
#Change params to be the
params_Default[paramx] <- paramcombos$x_parameter[i]
params_Default[(paramy + 9)] <- paramcombos$y_parameter[i]
#
params_Bauch <- c(r_1 = params_Default$r_1, s_1 = params_Default$s_1, h_1 = params_Default$h_1, k_1 = params_Default$k_1,
w_1 = params_Default$w_1, c_1 = params_Default$c_1, d_1 = params_Default$d_1, i_1 = params_Default$i_1,
rho_1 =  params_Default$rho_1,
r_2 = params_Default$r_2, s_2 = params_Default$s_2, h_2 = params_Default$h_2, k_2 = params_Default$k_2,
w_2 = params_Default$w_2, c_2 = params_Default$c_2, d_2 = params_Default$d_2, i_2 = params_Default$i_2,
rho_2 = params_Default$rho_2)
#
times <- timespan
xstart <- c(F_1 = 0.406, F_2 = 0.406, X_1 = .24, X_2 = .24) #See supplemental for other starting params
ode(
func=Bauch.Coupled,
y=xstart,
times=times,
parms=params_Bauch
) %>%
as.data.frame() -> out_Diff
finalstatus <- out_Diff[nrow(out_Diff),]
# out_Diff %>%
# filter(times == 100)
outcomes[i,] <- c(paramcombos$x_parameter[i], paramcombos$y_parameter[i], finalstatus$P_1, finalstatus$P_2)
}
finalDynamics <- outcomes %>%
mutate(Result = case_when(
Fish1 >= .25 & Fish2 >= .25 ~ "Both",
Fish1 >= .25 & Fish2 < .25 ~ "Only Pop1",
Fish1 < .25 & Fish2 >= .25 ~ "Only Pop2",
Fish1 < .25 & Fish2 < .25 ~ "Neither"))
cols <- c("green", "orange", "yellow", "black")
#Binned Colors
ggplot(finalDynamics, aes(XParameter, YParameter, fill = Result)) + geom_tile(width=1) +
scale_fill_manual(
values = c("Both" = "green",
"Only Pop1" = "orange",
"Only Pop2" = "yellow",
"Neither" = "black")) +
xlab(paramlist[paramx]) +
ylab(paramlist[paramy])
}
#paramplane(1, 3, 1, 1)
paramplane_testing <- function(boop){
pl <- list()
param_tests <- expand.grid(firstParam = seq(from = 1, to = 9, length.out = 9),
secondParam = seq(from = 1, to = 9, length.out = 9))
param_tests <- param_tests %>%
filter(firstParam != secondParam) %>%
filter(firstParam == boop)
for(i in 1:nrow(param_tests)){
pl[[i]] <- paramplane(param_tests$firstParam[i], param_tests$secondParam[i], 1, 1)
}
do.call("grid.arrange", c(pl,  ncol=2))
}
#grid.expand stuff
paramplane_testing(1)
params_Default <- params_list
#Change params to be the
#
params_Bauch <- c(r_1 = params_Default$r_1, s_1 = params_Default$s_1, h_1 = params_Default$h_1, k_1 = params_Default$k_1,
w_1 = params_Default$w_1, c_1 = params_Default$c_1, d_1 = params_Default$d_1, i_1 = params_Default$i_1,
rho_1 =  params_Default$rho_1,
r_2 = params_Default$R_2, s_2 = params_Default$s_2, h_2 = params_Default$h_2, k_2 = params_Default$k_2,
w_2 = params_Default$w_2, c_2 =params_Default$c_2, d_2 = params_Default$d_2, i_2 = params_Default$i_2,
rho_2 = params_Default$rho_2)
params_Bauch
#Change params to be the
#
params_Default[param] <- paramcombos$pop1_parameter[i]
#Create list of all combinations of the two paramters
paramcombos <- expand.grid(pop1_parameter = seq(from = start, to = max, length.out = 10),
pop2_parameter = seq(from = start, to = max, length.out = 10))
#Dumb but it throws an error if S = 0
start <- 0
param <- 1
max <- 1
#Create list of all combinations of the two paramters
paramcombos <- expand.grid(pop1_parameter = seq(from = start, to = max, length.out = 10),
pop2_parameter = seq(from = start, to = max, length.out = 10))
params_Default <- params_list
#Change params to be the
#
params_Default[param] <- paramcombos$pop1_parameter[i]
#Change params to be the
#
params_Default[param] <- paramcombos$pop1_parameter[1]
params_Default[(param + 9)] <- paramcombos$pop2_parameter[1]
params_Bauch <- c(r_1 = params_Default$r_1, s_1 = params_Default$s_1, h_1 = params_Default$h_1, k_1 = params_Default$k_1,
w_1 = params_Default$w_1, c_1 = params_Default$c_1, d_1 = params_Default$d_1, i_1 = params_Default$i_1,
rho_1 =  params_Default$rho_1,
r_2 = params_Default$R_2, s_2 = params_Default$s_2, h_2 = params_Default$h_2, k_2 = params_Default$k_2,
w_2 = params_Default$w_2, c_2 =params_Default$c_2, d_2 = params_Default$d_2, i_2 = params_Default$i_2,
rho_2 = params_Default$rho_2)
params_Bauch
params_Bauch <- c(r_1 = params_Default$r_1, s_1 = params_Default$s_1, h_1 = params_Default$h_1, k_1 = params_Default$k_1,
w_1 = params_Default$w_1, c_1 = params_Default$c_1, d_1 = params_Default$d_1, i_1 = params_Default$i_1,
rho_1 =  params_Default$rho_1,
r_2 = params_Default$r_2, s_2 = params_Default$s_2, h_2 = params_Default$h_2, k_2 = params_Default$k_2,
w_2 = params_Default$w_2, c_2 =params_Default$c_2, d_2 = params_Default$d_2, i_2 = params_Default$i_2,
rho_2 = params_Default$rho_2)
params_Bauch
ode(
func=Bauch.Coupled,
y=xstart,
times=times,
parms=params_Bauch
) %>%
as.data.frame() -> out_Diff
popplane <- function(param, max){
#Create empty dataframe to fill
paramlist <- c("r", "s", "h", "k", "s", "c", "d", "i", "rho")
outcomes <- data.frame(matrix(ncol = 4, nrow = 0))
colnames(outcomes) <- c("Pop1Parameter", "Pop2Parameter", "Fish1", "Fish2")
#Dumb but it throws an error if S = 0
start <- 0
if(param == 2){start <- .001}
#if(param == 3){max <- .1}
#Create list of all combinations of the two paramters
paramcombos <- expand.grid(pop1_parameter = seq(from = start, to = max, length.out = 10),
pop2_parameter = seq(from = start, to = max, length.out = 10))
for(i in 1:nrow(paramcombos)){
params_Default <- params_list
#Change params to be the
#
params_Default[param] <- paramcombos$pop1_parameter[i]
params_Default[(param + 9)] <- paramcombos$pop2_parameter[i]
params_Bauch <- c(r_1 = params_Default$r_1, s_1 = params_Default$s_1, h_1 = params_Default$h_1, k_1 = params_Default$k_1,
w_1 = params_Default$w_1, c_1 = params_Default$c_1, d_1 = params_Default$d_1, i_1 = params_Default$i_1,
rho_1 =  params_Default$rho_1,
r_2 = params_Default$r_2, s_2 = params_Default$s_2, h_2 = params_Default$h_2, k_2 = params_Default$k_2,
w_2 = params_Default$w_2, c_2 =params_Default$c_2, d_2 = params_Default$d_2, i_2 = params_Default$i_2,
rho_2 = params_Default$rho_2)
times <- timespan
xstart <- c(F_1 = 0.406, F_2 = 0.406, X_1 = .24, X_2 = .24) #See supplemental for other starting params
ode(
func=Bauch.Coupled,
y=xstart,
times=times,
parms=params_Bauch
) %>%
as.data.frame() -> out_Diff
finalstatus <- out_Diff[nrow(out_Diff),]
# out_Diff %>%
# filter(times == 100)
outcomes[i,] <- c(paramcombos$pop1_parameter[i], paramcombos$pop2_parameter[i], finalstatus$P_1, finalstatus$P_2)
}
finalDynamics <- outcomes %>%
mutate(Result = case_when(
Fish1 >= .25 & Fish2 >= .25 ~ "Both",
Fish1 >= .25 & Fish2 < .25 ~ "Only Pop1",
Fish1 < .25 & Fish2 >= .25 ~ "Only Pop2",
Fish1 < .25 & Fish2 < .25 ~ "Neither"))
cols <- c("green", "orange", "yellow", "black")
#Binned Colors
ggplot(finalDynamics, aes(Pop1Parameter, Pop2Parameter, fill = Result)) + geom_tile(width=1) +
scale_fill_manual(
values = c("Both" = "green",
"Only Pop1" = "orange",
"Only Pop2" = "yellow",
"Neither" = "black")) +
ggtitle(paste0(paramlist[param], " Parameter plane")) +
xlab(paste0(paramlist[param], " Population 1")) +
ylab(paste0(paramlist[param], " Population 2"))
}
popplane(1, 1)
popplane(2, 1)
knitr::opts_chunk$set(echo = FALSE, warning = FALSE, message = FALSE, dev="cairo_pdf")
#knitr::write_bib look into
setwd("C:/Users/sophi/Documents/GitHub/UNH_Docs/Proposal/Soc_Ecol_Model")
ModelNoSocial <- function (t, y, params) {
## first extract the state variables
F_1 <- y[1] #Fish Pop var
F_2 <- y[2] #Fish Pop var
#TT <- y[5]
## now extract the parameters
r_1 <- params["r_1"] # Net growth/fecundity
s_1 <- params["s_1"] # supply and demand
h_1 <- params["h_1"] # Harvesting efficiency
prop_1 <- params["prop_1"]
r_2 <- params["r_2"] # Net growth/fecundity
s_2 <- params["s_2"] # supply and demand
h_2 <- params["h_2"] # Harvesting efficiency
prop_2 <- params["prop_2"]
i_1 <- params["i_1"] # Inflow of fish from pop 2 to pop 1
i_2 <- params["i_2"] # Inflow of fish from pop 1 to pop 2
## now code the model equations
dF_1dt <-  r_1 * F_1 * (1-F_1) - (h_1 * F_1 * prop_1)/(F_1+s_1) - i_2 * F_1 + i_1 * F_2
dF_2dt <-  r_2 * F_2 * (1-F_2) - (h_2 * F_2 * prop_2)/(F_2+s_2) - i_1 * F_2 + i_2 * F_1
## combine results into a single vector
dydt <- c(dF_1dt, dF_2dt)
## return result as a list!
list(dydt)
}
params_uncoupled1 <- data.frame(r_1 = params_default$r_1, s_1 = params_default$s_1, h_1 = params_default$h_1, i_1 = params_default$i_1,
r_2 = params_default$r_2, s_2 = params_default$s_2, h_2 = params_default$h_2, i_2 = params_default$i_2, prop_1 = .5, prop_2 = .5)
param_names <- c("r_1", "s_1", "h_1", "k_1", "w_1", "c_1", "d_1", "i_1", "rho_1",
"r_2", "s_2", "h_2", "k_2", "w_2", "c_2", "d_2", "i_2", "rho_2")
params_default <- data.frame(r_1 = 0.35, s_1 = 0.8, h_1 = 0.5, k_1 = 1.014, w_1 = 0.35, c_1 = 1.5, d_1 = 0.5, i_1 = 0.2, rho_1 = 0.5,
r_2 = 0.35, s_2 = 0.8, h_2 = 0.5, k_2 = 1.014, w_2 = 0.35, c_2 = 1.5, d_2 = 0.5, i_2 = 0.2, rho_2 = 0.5)
timespan <- seq(from = 0, to = 100, by = .1)
ModelNoSocial <- function (t, y, params) {
## first extract the state variables
F_1 <- y[1] #Fish Pop var
F_2 <- y[2] #Fish Pop var
#TT <- y[5]
## now extract the parameters
r_1 <- params["r_1"] # Net growth/fecundity
s_1 <- params["s_1"] # supply and demand
h_1 <- params["h_1"] # Harvesting efficiency
prop_1 <- params["prop_1"]
r_2 <- params["r_2"] # Net growth/fecundity
s_2 <- params["s_2"] # supply and demand
h_2 <- params["h_2"] # Harvesting efficiency
prop_2 <- params["prop_2"]
i_1 <- params["i_1"] # Inflow of fish from pop 2 to pop 1
i_2 <- params["i_2"] # Inflow of fish from pop 1 to pop 2
## now code the model equations
dF_1dt <-  r_1 * F_1 * (1-F_1) - (h_1 * F_1 * prop_1)/(F_1+s_1) - i_2 * F_1 + i_1 * F_2
dF_2dt <-  r_2 * F_2 * (1-F_2) - (h_2 * F_2 * prop_2)/(F_2+s_2) - i_1 * F_2 + i_2 * F_1
## combine results into a single vector
dydt <- c(dF_1dt, dF_2dt)
## return result as a list!
list(dydt)
}
params_uncoupled1 <- data.frame(r_1 = params_default$r_1, s_1 = params_default$s_1, h_1 = params_default$h_1, i_1 = params_default$i_1,
r_2 = params_default$r_2, s_2 = params_default$s_2, h_2 = params_default$h_2, i_2 = params_default$i_2, prop_1 = .5, prop_2 = .5)
params_uncoupled2 <- data.frame(r_1 = params_default$r_1, s_1 = params_default$s_1, h_1 = params_default$h_1, i_1 = params_default$i_1,
r_2 = params_default$r_2, s_2 = params_default$s_2, h_2 = params_default$h_2, i_2 = params_default$i_2, prop_1 = .75, prop_2 = .25)
times <- timespan
xstart <- starting_defaultparams[1:2] # See supplemental data for other starting params
xstart <- c(F_1 = 0.406, F_2 = 0.406) # See supplemental data for other starting params
ode(
func=ModelNoSocial,
y=xstart,
times=times,
parms=params_uncoupled1
) %>%
as.data.frame() -> out_Uncoupled1
out_Uncoupled1 %>%
gather(variable,value,-time) %>%
ggplot(aes(x=time,y=value,color=variable))+
geom_line(size=1)+
theme_classic()+
labs(x='time (yr)',y='pop')
ode(
func=ModelNoSocial,
y=xstart,
times=times,
parms=params_uncoupled2
) %>%
as.data.frame() -> out_Uncoupled2
ode(
func=ModelNoSocial,
y=xstart,
times=times,
parms=params_uncoupled2
) %>%
as.data.frame() -> out_Uncoupled2
out_Uncoupled2 %>%
gather(variable,value,-time) %>%
ggplot(aes(x=time,y=value,color=variable))+
geom_line(size=1)+
theme_classic()+
labs(x='time (yr)',y='pop')
ModelNoSocial <- function (t, y, params) {
## first extract the state variables
F_1 <- y[1] #Fish Pop var
F_2 <- y[2] #Fish Pop var
#TT <- y[5]
## now extract the parameters
r_1 <- params["r_1"] # Net growth/fecundity
s_1 <- params["s_1"] # supply and demand
h_1 <- params["h_1"] # Harvesting efficiency
prop_1 <- params["prop_1"]
r_2 <- params["r_2"] # Net growth/fecundity
s_2 <- params["s_2"] # supply and demand
h_2 <- params["h_2"] # Harvesting efficiency
prop_2 <- params["prop_2"]
i_1 <- params["i_1"] # Inflow of fish from pop 2 to pop 1
i_2 <- params["i_2"] # Inflow of fish from pop 1 to pop 2
## now code the model equations
dF_1dt <-  r_1 * F_1 * (1-F_1) - (h_1 * F_1 * prop_1)/(F_1+s_1) - i_2 * F_1 + i_1 * F_2
dF_2dt <-  r_2 * F_2 * (1-F_2) - (h_2 * F_2 * prop_2)/(F_2+s_2) - i_1 * F_2 + i_2 * F_1
## combine results into a single vector
dydt <- c(dF_1dt, dF_2dt)
## return result as a list!
list(dydt)
}
params_uncoupled1 <- data.frame(r_1 = params_default$r_1, s_1 = params_default$s_1, h_1 = params_default$h_1, i_1 = params_default$i_1,
r_2 = params_default$r_2, s_2 = params_default$s_2, h_2 = params_default$h_2, i_2 = params_default$i_2, prop_1 = .5, prop_2 = .5)
params_uncoupled2 <- data.frame(r_1 = params_default$r_1, s_1 = params_default$s_1, h_1 = params_default$h_1, i_1 = params_default$i_1,
r_2 = params_default$r_2, s_2 = params_default$s_2, h_2 = params_default$h_2, i_2 = params_default$i_2, prop_1 = .75, prop_2 = .25)
times <- timespan
xstart <- c(F_1 = 0.406, F_2 = 0.406) # See supplemental data for other starting params
ode(
func=ModelNoSocial,
y=xstart,
times=times,
parms=params_uncoupled1
) %>%
as.data.frame() -> out_Uncoupled1
out_Uncoupled1 %>%
gather(variable,value,-time) %>%
ggplot(aes(x=time,y=value,color=variable))+
geom_line(size=1)+
theme_classic()+
labs(x='time (yr)',y='pop')
ode(
func=ModelNoSocial,
y=xstart,
times=times,
parms=params_uncoupled2
) %>%
as.data.frame() -> out_Uncoupled2
out_Uncoupled2 %>%
gather(variable,value,-time) %>%
ggplot(aes(x=time,y=value,color=variable))+
geom_line(size=1)+
theme_classic()+
labs(x='time (yr)',y='pop')
knitr::opts_chunk$set(echo = FALSE, warning = FALSE, message = FALSE, dev="cairo_pdf")
#knitr::write_bib look into
setwd("C:/Users/sophi/Documents/GitHub/UNH_Docs/Proposal/Soc_Ecol_Model")
options(tinytex.verbose = TRUE)
ages <- data.frame(matrix(data = NA, nrow = 4, ncol = 3))
colnames(ages) <- c("Stage", "Duration_New", "Variance")
for(i in 1:4){
ages$Stage[i] <- i
ages$Duration_New[i] <- i
ages$Variance[i] <- i
}
knitr::kable(ages, format = "latex", booktabs = TRUE, caption = "(ref:captionlabel) \\label{tableEx}") #%>%
#kable_styling(latex_options="scale_down")
param_names <- c("r_1", "s_1", "h_1", "k_1", "w_1", "c_1", "d_1", "i_1", "rho_1",
"r_2", "s_2", "h_2", "k_2", "w_2", "c_2", "d_2", "i_2", "rho_2")
params_default <- data.frame(r_1 = 0.35, s_1 = 0.8, h_1 = 0.5, k_1 = 1.014, w_1 = 0.35, c_1 = 1.5, d_1 = 0.5, i_1 = 0.2, rho_1 = 0.5,
r_2 = 0.35, s_2 = 0.8, h_2 = 0.5, k_2 = 1.014, w_2 = 0.35, c_2 = 1.5, d_2 = 0.5, i_2 = 0.2, rho_2 = 0.5)
starting_defaultparams <- c(F_1 = 0.406, F_2 = 0.406, X_1 = .24, X_2 = .24)
timespan <- seq(from = 0, to = 100, by = .1)
ModelNoSocial <- function (t, y, params) {
## first extract the state variables
F_1 <- y[1] #Fish Pop var
F_2 <- y[2] #Fish Pop var
#TT <- y[5]
## now extract the parameters
r_1 <- params["r_1"] # Net growth/fecundity
s_1 <- params["s_1"] # supply and demand
h_1 <- params["h_1"] # Harvesting efficiency
prop_1 <- params["prop_1"]
r_2 <- params["r_2"] # Net growth/fecundity
s_2 <- params["s_2"] # supply and demand
h_2 <- params["h_2"] # Harvesting efficiency
prop_2 <- params["prop_2"]
i_1 <- params["i_1"] # Inflow of fish from pop 2 to pop 1
i_2 <- params["i_2"] # Inflow of fish from pop 1 to pop 2
## now code the model equations
dF_1dt <-  r_1 * F_1 * (1-F_1) - (h_1 * F_1 * prop_1)/(F_1+s_1) - i_2 * F_1 + i_1 * F_2
dF_2dt <-  r_2 * F_2 * (1-F_2) - (h_2 * F_2 * prop_2)/(F_2+s_2) - i_1 * F_2 + i_2 * F_1
## combine results into a single vector
dydt <- c(dF_1dt, dF_2dt)
## return result as a list!
list(dydt)
}
params_uncoupled1 <- data.frame(r_1 = params_default$r_1, s_1 = params_default$s_1, h_1 = params_default$h_1, i_1 = params_default$i_1,
r_2 = params_default$r_2, s_2 = params_default$s_2, h_2 = params_default$h_2, i_2 = params_default$i_2, prop_1 = .5, prop_2 = .5)
params_uncoupled2 <- data.frame(r_1 = params_default$r_1, s_1 = params_default$s_1, h_1 = params_default$h_1, i_1 = params_default$i_1,
r_2 = params_default$r_2, s_2 = params_default$s_2, h_2 = params_default$h_2, i_2 = params_default$i_2, prop_1 = .75, prop_2 = .25)
times <- timespan
xstart <- c(F_1 = 0.406, F_2 = 0.406) # See supplemental data for other starting params
ode(
func=ModelNoSocial,
y=xstart,
times=times,
parms=params_uncoupled1
) %>% as.data.frame() -> out_Uncoupled1
out_Uncoupled1 %>%
gather(variable,value,-time) %>%
ggplot(aes(x=time,y=value,color=variable))+
geom_line(size=1)+
theme_classic()+
labs(x='time (yr)',y='pop')
ode(
func=ModelNoSocial,
y=xstart,
times=times,
parms=params_uncoupled2
) %>% as.data.frame() -> out_Uncoupled2
out_Uncoupled2 %>%
gather(variable,value,-time) %>%
ggplot(aes(x=time,y=value,color=variable))+
geom_line(size=1)+
theme_classic()+
labs(x='time (yr)',y='pop')
