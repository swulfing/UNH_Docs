})
writeLines(c(begin, X, end))
}
knitr::include_graphics("LifeGraph.png")
knitr::include_graphics("MtxGeneric.png")
#Make Z
z <- matrix(t(observedStageMatrix[2:11,]), ncol = 1, nrow = 40, byrow = TRUE)
#z
#Make M
m <- matrix(, nrow = nrow(z) , ncol = 8)
for(i in 1:(nrow(observedStageMatrix)-3)){
m[(4 * (i-1) + 1):(4 * i),] <- matrix(c(observedStageMatrix[i,1], 0, 0, 0, 0, 0, observedStageMatrix[i,4], 0,
0, observedStageMatrix[i,1], observedStageMatrix[i,2], 0, 0, 0, 0, 0,
0, 0, 0, observedStageMatrix[i,2], observedStageMatrix[i,3], 0, 0, 0,
0, 0, 0, 0, 0, observedStageMatrix[i,3], 0, observedStageMatrix[i,4]),
nrow = 4, byrow = TRUE)
#m
}
#Make C
c <- matrix(c(diag(8) * (-1),
1, 1, 0, 0, 0, 0, 0, 0,
0, 0, 1, 1, 0, 0, 0, 0,
0, 0, 0, 0, 1, 1, 0, 0,
0, 0, 0, 0, 0, 0, 0, 1), nrow = 12, ncol = 8, byrow = TRUE)
#c
#Make b
b <- matrix(c(rep(0,8), rep(1,4)), nrow = 12, ncol = 1, byrow = TRUE)
#Make P
#p <- matrix(, nrow = 8, ncol = 1, byrow = TRUE) #vector(p1, g1, p2, g2, p3, g3, f4, p4)
#Make mtx G and vector x
g <- t(m) %*% m
f_t <- -(t(-z) %*% m)
qp <- solve.QP(Dmat = g, dvec = f_t, Amat = -t(c), bvec = -t(b))#, factorized = FALSE)
A <- matrix(c(qp$solution[1], 0, 0, qp$solution[7],
qp$solution[2], qp$solution[3], 0, 0,
0, qp$solution[4], qp$solution[5], 0,
0, 0, qp$solution[6], qp$solution[8]), byrow = TRUE, nrow = 4, ncol = 4)
#A
A_round <- matrix( , byrow = TRUE, nrow = 4, ncol = 4)
for (i in 1:length(A)){
A_round[i] <- round(A[i], 3)
}
# A_round <- matrix(-1*c(qp_round[1], 0, 0, qp_round[7],
#               qp_round[2], qp_round[3], 0, 0,
#               0, qp_round[4], qp_round[5], 0,
#               0, 0, qp_round[6], qp_round[8]), byrow = TRUE, nrow = 4, ncol = 4)
round_A <- matrix(A_round, 4, 4)
round_A[1] <- paste0("P1 = ", round_A[1])
round_A[13] <- paste0("F4 = ", round_A[13])
round_A[2] <- paste0("G1 = ", round_A[2])
round_A[6] <- paste0("P2 = ", round_A[6])
round_A[7] <- paste0("G2 = ", round_A[7])
round_A[11] <- paste0("P3 = ", round_A[11])
round_A[12] <- paste0("G3 = ", round_A[12])
round_A[16] <- paste0("P4 = ", round_A[16])
knitr::include_graphics("MtxFilled.png")
#write_matex(round_A)
ages <- data.frame(matrix(data = NA, nrow = 4, ncol = 3))
colnames(ages) <- c("Stage", "Duration_New", "Variance")
for(i in 1:nrow(A)){
ages$Stage[i] <- i
ages$Duration_New[i] <- 1/(1-A[i,i])
ages$Variance[i] <- A[i,i]/(1-A[i,i])^2
}
Life <- read.csv("OcyaneaLifeHistory.csv")
LifeHistory <- Life[,1:2]
LifeHistory$New <- c(NA, NA, ages[,2], NA, NA )
LifeHistory$Var <- c(NA, NA, ages[,3], NA, NA )
colnames(LifeHistory) <- c("Stage", "Existing Estimate", "Estimate from Lefkovitch Matrix", "Variance")
#LifeHistory
#Nowcombine LifeHistory[1:2]
knitr::kable(LifeHistory, format = "latex", booktabs = TRUE, caption = "(ref:lifehistory) \\label{LifeHistory}") #%>%
#kable_styling(latex_options="scale_down")
pop <- observedStageMatrix[13,]
N <- list()
#72 mo projection
for (i in 1:120){
N[[1]] <- pop
N[[i+1]] <- A %*% N[[i]]
}
modeled_data <- t(as.data.frame(do.call(cbind, N)))
colnames(modeled_data) <- c("Stage_1", "Stage_2", "Stage_3", "Stage_4")
modeled_data <- cbind(modeled_data, month = 0:120)
#write.csv(modeled_data, "testing.csv",row.names = TRUE)
modeled_data <- data.frame(modeled_data)
ggplot(modeled_data) +
geom_line(aes(y = Stage_1, x = month, color = "Stage 1", linetype = "Stage 1"), size = .75) +
geom_line(aes(y = Stage_2, x = month, color = "Stage 2", linetype = "Stage 2"), size = .75) +
geom_line(aes(y = Stage_3, x = month, color = "Stage 3", linetype = "Stage 3"), size = .75) +
geom_line(aes(y = Stage_4, x = month, color = "Stage 4", linetype = "Stage 4"), size = .75) +
scale_color_manual(name = "", values = c("Stage 1" = "#004949",
"Stage 2" = "#009292",
"Stage 3" = "#db6d00",
"Stage 4" = "#920000")) +
scale_linetype_manual(name = "", values = c("Stage 1" = 3,
"Stage 2" = 4,
"Stage 3" = 5,
"Stage 4" = 1)) +
#ggtitle("Ten year population projection") + #paste0(i, " month projection")) +
xlab("Year") +
ylab("No. Individuals") +
scale_x_continuous(breaks = seq(0, 120, 12), label = seq(2006, 2016)) +
theme_bw() +
theme(panel.border = element_blank(), panel.grid.major = element_blank(), panel.grid.minor = element_blank(), axis.line = element_line(colour = "black"))
#eigenvecors and vals
A_eigen <- eigen(A)
#A_eigen
#Intrinsic Rate of Increast (r): lambda = e^r
r <- log(A_eigen$values[1])
#r
#stable stage dist
A_stable_stage <-as.numeric(A_eigen$vectors[,1]/sum(A_eigen$vectors[,1]))
#A_stable_stage
#reproductive value
A_repro_value <- as.numeric(eigen(t(A))$vectors[,1]/eigen(t(A))$vectors[1,1])
#A_repro_value
#mean reproductive value- is the avg no offspring?
#A_repro_value %*% A_stable_stage
#. Vandermeer (1975, 1978)
lifetable <- data.frame(matrix(ncol = 3, nrow = 4))
#x <- c("Stage", "Stable Stage Distribution (Dominant Eigenvector)", "Reproductive Value (Left Eigenvector)")
#colnames(lifetable) <- x
#colnames(lifetable) <- stringr::str_replace_all(colnames(lifetable), "\\n", "<br>")
lifetable[1:4,1] <- c("1 Immature", "2 Incipient Maturity", "3 Mature", "4 Fully Mature")
lifetable[1:4,2] <- round(A_stable_stage,3)
lifetable[1:4,3] <- round(A_repro_value,3)
#colnames(lifetable) <- stringr::str_replace_all(colnames(lifetable), "\\n", "<br>")
knitr::kable(lifetable, format = "latex", booktabs = TRUE, caption = "(ref:lifetablecap) \\label{lifetable}", col.names = c("Stage", "Stable Stage Distribution (Dominant Eigenvector)", "Reproductive Value (Left Eigenvector)")) %>%
column_spec(2:3, width = "4.5cm") %>%
kable_styling(latex_options="scale_down")
surviveTable <- data.frame(matrix(ncol = 2, nrow = 5))
y <- c("Stage", "Survivability")
colnames(surviveTable) <- y
surviveTable[1:5,1] <- c("1 Immature", "2 Incipient Maturity", "3 Mature", "4 Fully Mature", "Larval")
for(i in 1:3){
surviveTable[i,2] <- sum(A[,i])
}
surviveTable[4,2] <- A[4,4]
surviveTable[5,2] <- A[1,4]/((375000+27000)/2)
knitr::kable(surviveTable, format = "latex", booktabs = TRUE, caption = "(ref:surviveTable) \\label{survivabilityEst}") #%>%
#kable_styling(latex_options="scale_down")
cols <- hcl.colors(1000, palette = "Greens 3", alpha = NULL, rev = TRUE, fixup = TRUE)#, end = .85)
sens <- sensitivity(A)
for(i in 1:length(A)){
if(A[i] == 0){
sens[i] <-  NA
}
}
## IMAGE plot with smaller boxes
image2(sens, mar=c(1,3.5,5,1), box.offset=.1, border="gray70",col = c("white", cols[150:850]), text.cex = 2)
## MATPLOT
# matplot2(sens, log='y', type='b', yaxt='n', ltitle="Fate",
#  ylab=expression(paste("Sensitivity of ",lambda)),
#  main="Sensitivity matrix using matplot2")
# pwrs <- -4:1
#  #axis(2, 10^pwrs, parse(text=paste("10^", pwrs, sep = "")), las=1)
#https://rdrr.io/cran/popbio/man/sensitivity.html
#
cols <- hcl.colors(1000, palette = "Greens 3", alpha = NULL, rev = TRUE, fixup = TRUE)#, end = .85)
elas <- elasticity(A)
for(i in 1:length(A)){
if(A[i] == 0){
elas[i] <-  NA
}
}
image2(elas, mar=c(1,3.5,5,1), border="gray70", col = c("white", cols[150:850]), text.cex = 2 )
# # Summed elasticities for teasel.
# # fertility in last column, stasis P on diagonal, and growth in bottom-left triangle
# c(F=sum(elas[,4]), P=sum(diag(elas)), G=sum(elas[row(elas)>col(elas)]))
#
# elas <- elasticity(tortoise[["med.high"]])
# image2(elas, mar=c(1,3.5,5,1),  log=FALSE)
#  title("Tortoise elasticity matrix", line=2.5)
# # Summed elasticities for tortoise (see example 9.4)
# # fertility in top row, stasis on diagonal, and growth on subdiagonal
# c(F=sum(elas[1,]), P=sum(diag(elas)), G=sum(elas[row(elas)==col(elas)+1]))
#https://rdrr.io/cran/popbio/man/elasticity.html
rates <- c(0, 0, 0, 0, 0)
for(i in 1:(length(rates)-1)){
#First need to do the stage 4 and larval differently
if(i == 4){
incr <- 0.01
testMtx <- A
testMtx[4,4] <- A[4,4] + A[4,4] * incr
while(f(eigen(testMtx)$values[1]) < 1){
incr <- incr + 0.01
testMtx[4,4] <- A[4,4] + A[4,4] * incr
}
rates[4] <- incr
incr <- 0.01
testMtx <- A
testMtx[1,4] <- A[1,4] + A[1,4] * incr
while(f(eigen(testMtx)$values[1]) < 1){
incr <- incr + 0.01
testMtx[1,4] <- A[1,4] + A[1,4] * incr
}
rates[5] <- incr
}
else{
incr <- 0.01
testMtx <- A
testMtx[,i] <- A[,i] + A[,i] * incr
while(f(eigen(testMtx)$values[1]) < 1){
incr <- incr + 0.01
testMtx[,i] <- A[,i] + A[,i] * incr
}
rates[i] <- incr
}}
rates_percent <- rates * 100
barplot(rates_percent, xlab = "Stage", ylab = "Percent survival increase",
names.arg=c("1", "2", "3", "4", "Larval"))
#rates
#Calculates new rates based on vectors of % chagne and frequencies of restrictions
p <- list()
modeled_data <- data.frame(matrix(ncol=8,nrow=0, dimnames=list(NULL, c("Stage_1", "Stage_2", "Stage_3", "Stage_4", "month", "pop", "Frequency", "PercentChange"))))
percentage <-rates <- c(seq(0, .1, .01)) # c(0.01, 0.05, 0.1, 0.15)
freqs <- c(seq(1, 12)) #c(1, 2, 3, 4, 6, 12)
#par(mfrow = c(6,4))
for(i in 1:length(freqs)){
for(j in 1:length(percentage)){
pop <- observedStageMatrix[13,]
N <- list()
for (k in 1:120){
if(k %% 12 %in% c(seq(1, freqs[i]))){
N[[1]] <- pop
N[[k+1]] <- survivability(percentage[j]) %*% N[[k]]
}
else{
N[[1]] <- pop
N[[k+1]] <- A %*% N[[k]]
}}
new_data <- t(as.data.frame(do.call(cbind, N)))
colnames(new_data) <- c("Stage_1", "Stage_2", "Stage_3", "Stage_4")
new_data <- data.frame(cbind(new_data, month = 0:120, pop = rowSums(new_data[,1:4]), Frequency = freqs[i], PercentChange = percentage[j]))
modeled_data <- rbind(modeled_data, new_data)
}}
# Sources: https://www.webpages.uidaho.edu/wlf448/stochgro.pdf
# https://esajournals.onlinelibrary.wiley.com/doi/10.2307/1943004
#### CALCULATE GROWTH RATE BASED ON LAST POP-FIRST POP/FIRST POP FOR EACH FREQ/PERCENT COMBINATION
growthRate <- modeled_data %>%
select(month, pop, Frequency, PercentChange) %>%
filter(month == 0 | month == 120) %>%
pivot_wider(names_from = month, values_from = pop) %>%
rename(month_0 = 3,
month_120 = 4) %>%
mutate(Mu_New = log(month_120/month_0)/120) %>% #See Crouse paper. From Nt = N0e^(rt)
mutate(lambda_new = exp(Mu_New)) %>%
select(Frequency, PercentChange, Mu_New, lambda_new)
#### COPY PARETTO GRAPH FROM OTHER ANALYSIS
paretospagheto <- growthRate %>%
filter(lambda_new >= 1) %>%
group_by(Frequency) %>%
filter(lambda_new == min(lambda_new))
View(growthRate)
correlationplot <- data.frame(cor(SnsBactcorr[,-(1:2)]))
## pairwise correlation
SnsBactcorr <- sensFun(func = BauchSensitivity, parms = params_default, sensvar = c("F_1","F_2"), varscale = 1)
knitr::opts_chunk$set(echo = FALSE, warning = FALSE, message = FALSE)
setwd("C:/Users/sophi/Documents/GitHub/UNH_Docs/Proposal/Soc_Ecol_Model")
library(deSolve)
library(tidyverse)
library(ggplot2)
library(gridExtra)
library(kableExtra)
#library(ODEsensitivity)
library(FME)
params_default <- data.frame(r_1 = 0.35, s_1 = 0.8, h_1 = 0.5, k_1 = 1.014, w_1 = 0.35, c_1 = 1.5, d_1 = 0.5, i_1 = 0.2, roh_1 = 0.5,
r_2 = 0.35, s_2 = 0.8, h_2 = 0.5, k_2 = 1.014, w_2 = 0.35, c_2 = 1.5, d_2 = 0.5, i_2 = 0.2, roh_2 = 0.5)
starting_defaultparams <- c(F_1 = 0.406, F_2 = 0.406, X_1 = .24, X_2 = .24)
timespan <- seq(from = 0, to = 100, by = .1)
options(tinytex.verbose = TRUE)
giveparams <- data.frame(matrix(, nrow = 9, ncol = 4))
colnames(giveparams) <- c("Parameter", "Population_1", "Population_2", "Def")
giveparams$Parameter <- c("r", "s", "h", "k", "$\\omega$", "c", "d", "i", "$\\rho$")
giveparams$Population_1 <- c(params_default[1:9])
giveparams$Population_2 <- c(params_default[10:18])
giveparams$Def <- c("Fish net growth",
"Supply and demand",
"Harvesting efficiency",
"Social learning rate",
"Conservation cost",
"Rarity valuation",
"Social norm strength (within pop)",
"Fish immigration (from patch)",
"Social norm strength (opposite pop)")
knitr::kable(giveparams, format = "pandoc", booktabs = TRUE, caption = "Default parameter values used in this analysis")
givestart <- data.frame(matrix(, nrow = 2, ncol = 3))
colnames(givestart) <- c("Parameter", "Population_1", "Population_2")
givestart$Parameter <- c("F", "X")
givestart$Population_1 <- c(starting_defaultparams[1], starting_defaultparams[3])
givestart$Population_2 <- c(starting_defaultparams[2], starting_defaultparams[4])
knitr::kable(givestart, format = "latex", booktabs = TRUE, caption = "Starting values used in this analysis")
ModelNoSocial <- function (t, y, params) {
## first extract the state variables
F_1 <- y[1] #Fish Pop var
F_2 <- y[2] #Fish Pop var
#TT <- y[5]
## now extract the parameters
r_1 <- params["r_1"] # Net growth/fecundity
s_1 <- params["s_1"] # supply and demand
h_1 <- params["h_1"] # Harvesting efficiency
r_2 <- params["r_2"] # Net growth/fecundity
s_2 <- params["s_2"] # supply and demand
h_2 <- params["h_2"] # Harvesting efficiency
i_1 <- params["i_1"] # Inflow of fish from pop 2 to pop 1
i_2 <- params["i_2"] # Inflow of fish from pop 1 to pop 2
## now code the model equations
dF_1dt <-  r_1 * F_1 * (1-F_1) - (h_1 * F_1 * 0.50)/(F_1+s_1) - i_2 * F_1 + i_1 * F_2
dF_2dt <-  r_2 * F_2 * (1-F_2) - (h_2 * F_2 * 0.50)/(F_2+s_2) - i_1 * F_2 + i_2 * F_1
## combine results into a single vector
dydt <- c(dF_1dt, dF_2dt)
## return result as a list!
list(dydt)
}
params_Bauch2 <- data.frame(r_1 = params_default$r_1, s_1 = params_default$s_1, h_1 = params_default$h_1, i_1 = params_default$i_1,
r_2 = params_default$r_2, s_2 = params_default$s_2, h_2 = params_default$h_2, i_2 = params_default$i_2)
times <- timespan
xstart <- starting_defaultparams[1:2] # See supplemental data for other starting params
ode(
func=ModelNoSocial,
y=xstart,
times=times,
parms=params_Bauch2
) %>%
as.data.frame() -> out_Coupled
out_Coupled %>%
gather(variable,value,-time) %>%
ggplot(aes(x=time,y=value,color=variable))+
geom_line(size=1)+
theme_classic()+
labs(x='time (yr)',y='pop')
##Maybe see what proportion of people can actually be fishing in this system to make it sustainable
Bauch.Coupled <- function (t, y, params) {
## first extract the state variables
F_1 <- y[1] #Fish Pop var
F_2 <- y[2] #Fish Pop var
X_1 <- y[3] #conservationist var
X_2 <- y[4] #conservationist var
#TT <- y[5]
## now extract the parameters
r_1 <- params["r_1"] # Net growth/fecundity
s_1 <- params["s_1"] # supply and demand
h_1 <- params["h_1"] # Harvesting efficiency
k_1 <- params["k_1"] # Social learning rate
w_1 <- params["w_1"] # conservation costs
c_1 <- params["c_1"] # rarity valuation param
d_1 <- params["d_1"] # social norm strength
r_2 <- params["r_2"] # Net growth/fecundity
s_2 <- params["s_2"] # supply and demand
h_2 <- params["h_2"] # Harvesting efficiency
k_2 <- params["k_2"] # Social learning rate
w_2 <- params["w_2"] # conservation costs
c_2 <- params["c_2"] # rarity valuation param
d_2 <- params["d_2"] # social norm strength
i_1 <- params["i_1"] # Inflow of fish from pop 2 to pop 1
i_2 <- params["i_2"] # Inflow of fish from pop 1 to pop 2
roh_1 <- params["roh_1"] # Influence of pop 2 on pop 1
roh_2 <- params["roh_2"] # Influence of pop 1 on pop 2
## now code the model equations
dF_1dt <-  r_1 * F_1 * (1-F_1) - (h_1 * F_1 * (1-X_1))/(F_1+s_1) - i_2 * F_1 + i_1 * F_2
dF_2dt <-  r_2 * F_2 * (1-F_2) - (h_2 * F_2 * (1-X_2))/(F_2+s_2) - i_1 * F_2 + i_2 * F_1
dX_1dt <- k_1 * X_1 * (1-X_1) *(1/(F_1 + c_1) - w_1 + d_1*(2*X_1 - 1) + roh_1 * (2*X_2 - 1))
dX_2dt <- k_2 * X_2 * (1-X_2) *(1/(F_2 + c_2) - w_2 + d_2*(2*X_2 - 1) + roh_2 * (2*X_1 - 1))
## combine results into a single vector
dydt <- c(dF_1dt, dF_2dt, dX_1dt, dX_2dt)
## return result as a list!
list(dydt)
}
params_Bauch2 <- params_default
times <- timespan
xstart <- starting_defaultparams # See supplemental data for other starting params
ode(
func=Bauch.Coupled,
y=xstart,
times=times,
parms=params_Bauch2
) %>%
as.data.frame() -> out_Coupled
out_Coupled %>%
gather(variable,value,-time) %>%
ggplot(aes(x=time,y=value,color=variable))+
geom_line(size=1)+
theme_classic()+
labs(x='time (yr)',y='pop')
#Ok I have no clue wtf this is telling me
n <- 100 # NUMBER OF SIMULATIONS
param.name <- "w_1" # PARAM TO PERTURB
param.seq <- seq(0,1,length = 50) # RANGE OF PARAMETER
Pars <- params_default
Time <- seq(0, 10, length = n)
State <- starting_defaultparams
param.index <- which(param.name == names(Pars))
out <- list()
for (i in 1:length(param.seq)){
out[[i]] <- matrix(0, n, length(State))}
for (i in 1:length(param.seq)) {
# set params
Pars.loop <- Pars
Pars.loop[param.index] <- param.seq[i]
# converge
init <- ode(State, Time, Bauch.Coupled, Pars.loop)
# get converged points
out[[i]] <- ode(init[n,-1], Time, Bauch.Coupled, Pars.loop)[,-1]
}
range.lim <- lapply(out, function(x) apply(x, 2, range))
range.lim <- apply(do.call("rbind", range.lim), 2, range)
plot.variable <- "F_1" # CHOOSE WHICH VARIABLE TO SHOW
plot(0, 0, pch = "", xlab = param.name, ylab = plot.variable,
xlim = range(param.seq), ylim = range.lim[,plot.variable])
for (i in 1:length(param.seq)) {
points(rep(param.seq[i], n), out[[i]][,plot.variable])
}
BauchSensitivity <- function(pars){
derivs <- function (t, state, pars) {
with (as.list(c(state, pars)), {
## now code the model equations
dF_1dt <-  r_1 * F_1 * (1-F_1) - (h_1 * F_1 * (1-X_1))/(F_1+s_1) - i_2 * F_1 + i_1 * F_2
dF_2dt <-  r_2 * F_2 * (1-F_2) - (h_2 * F_2 * (1-X_2))/(F_2+s_2) - i_1 * F_2 + i_2 * F_1
dX_1dt <- k_1 * X_1 * (1-X_1) *(1/(F_1 + c_1) - w_1 + d_1*(2*X_1 - 1) + roh_1 * (2*X_2 - 1))
dX_2dt <- k_2 * X_2 * (1-X_2) *(1/(F_2 + c_2) - w_2 + d_2*(2*X_2 - 1) + roh_2 * (2*X_1 - 1))
return(list(c(dF_1dt, dF_2dt, dX_1dt, dX_2dt)))
})
}
state   <- starting_defaultparams
tout    <- timespan
## ode solves the model by integration ...
return(as.data.frame(ode(y = state, times = tout, func = derivs,
parms = pars)))
}
SnsBact <- sensFun(func = BauchSensitivity, parms = params_default, sensvar = "F_1", varscale = 1)
summary(SnsBact)
plot(summary(SnsBact))
plot(SnsBact, type = "b", pch = 15:19, col = 2:6,
main = "Sensitivity all vars")
plot(SnsBact, type = "b", pch = 15:19, col = 2:6,
main = "Sensitivity all vars")
SF <- SnsBact <- sensFun(func = BauchSensitivity, parms = params_default, sensvar = c("F_1", "F_2", "X_1", "X_2"), varscale = 1)
SF <- SnsBact <- sensFun(func = BauchSensitivity, parms = params_default, sensvar = c("F_1", "F_2", "X_1", "X_2"), varscale = 1)
SF <- SnsBact <- sensFun(func = BauchSensitivity, parms = params_default, sensvar = c("F_1", "F_2", "X_1", "X_2"), varscale = 1)
summary(SF, var = TRUE)
## pairwise correlation
SnsBactcorr <- sensFun(func = BauchSensitivity, parms = params_default, sensvar = c("F_1","F_2"), varscale = 1)
correlationplot <- data.frame(cor(SnsBactcorr[,-(1:2)]))
View(correlationplot)
correlationplot <- as.data.frame(cor(SnsBactcorr[,-(1:2)]))
View(correlationplot)
correlationplot[,1]
class(cor(SnsBactcorr[,-(1:2)]))
ncol(cor(SnsBactcorr[,-(1:2)]))
nrow(cor(SnsBactcorr[,-(1:2)]))
correlationplot <- matrix(cor(SnsBactcorr[,-(1:2)]), 18, 18)
cor(SnsBactcorr[,-(1:2)])
param_names <- c("r_1", "s_1", "h_1", "k_1", "w_1", "c_1", "d_1", "i_1", "roh_1",
"r_2", "s_2", "h_2", "k_2", "w_2", "c_2", "d_2", "i_2", "roh_2")
colnames(correlationplot) <- param_names
correlations <- matrix(cor(SnsBactcorr[,-(1:2)]), 18, 18)
colnames(correlations) <- param_names
correlationplot <- cbind(data.frame(param_names), correlations)
View(correlationplot)
correlationplot <- cbind(data.frame(param_names), correlations) %<%
gather(param_names, r_1:roh2)
correlationplot <- cbind(data.frame(param_names), correlations) %>%
gather(param_names, r_1:roh2)
correlationplot <- cbind(data.frame(param_names), correlations) %>%
gather(., param_names, r_1:roh2)
correlationplot <- cbind(data.frame(param_names), correlations) %>%
gather(., param_names)
correlationplot <- cbind(data.frame(param_names), correlations) #%>%
gather(correlationplot, param_names, r_1:roh_2)
class(correlationplot$param_names)
correlationplot <- cbind(data.frame(as.factor(param_names)), correlations) #%>%
gather(correlationplot, param_names, r_1:roh_2)
class(correlationplot$param_names)
View(correlationplot)
correlationplot <- cbind(data.frame(param_names), correlations)
correlationplot$param_names <- factor(correlationplot$param_names)
class(correlationplot$param_names)
gather(correlationplot, param_names, r_1:roh_2)
gather(correlationplot, param_names)
View(gather(correlationplot, param_names))
correlationplot <- cbind(data.frame(param_names), correlations) %>%
pivot_longer(param_names)
View(correlationplot)
correlationplot <- cbind(data.frame(param_names), correlations) %>%
pivot_longer("r_1", "s_1", "h_1", "k_1", "w_1", "c_1", "d_1", "i_1", "roh_1",
"r_2", "s_2", "h_2", "k_2", "w_2", "c_2", "d_2", "i_2", "roh_2")
correlationplot <- cbind(data.frame(param_names), correlations) %>%
pivot_longer()
correlationplot <- cbind(param1 = data.frame(param_names), correlations) %>%
pivot_longer()
correlationplot <- cbind(param1 = data.frame(param_names), correlations)# %>%
View(correlationplot)
correlationplot <- cbind(param1 = data.frame(param_names), correlations)# %>%
View(correlationplot)
pivot_longer(., c("r_1", "s_1", "h_1", "k_1", "w_1", "c_1", "d_1", "i_1", "roh_1",
"r_2", "s_2", "h_2", "k_2", "w_2", "c_2", "d_2", "i_2", "roh_2"))
pivot_longer(c("r_1", "s_1", "h_1", "k_1", "w_1", "c_1", "d_1", "i_1", "roh_1",
"r_2", "s_2", "h_2", "k_2", "w_2", "c_2", "d_2", "i_2", "roh_2"))
correlationplot <- cbind(param1 = data.frame(param_names), correlations) %>%
pivot_longer(c("r_1", "s_1", "h_1", "k_1", "w_1", "c_1", "d_1", "i_1", "roh_1",
"r_2", "s_2", "h_2", "k_2", "w_2", "c_2", "d_2", "i_2", "roh_2"))
View(correlationplot)
View(correlationplot)
ggplot(correlationplot, aes(param_names, name, fill = value)) + geom_tile(width=1) +
scale_fill_gradient2(
low = "red",
mid = "white",
high = "green",
#limits = c(1, max(growthRate$lambda_new)),
midpoint = 0,
space = "Lab",
na.value = "grey50") #+
