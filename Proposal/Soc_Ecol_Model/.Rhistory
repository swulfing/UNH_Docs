times=timespan,
parms=params_test
) %>%
as.data.frame() -> out_Coupled
#Compile output into Dataframe
finalDynamics$F1[i] <- out_Coupled[nrow(out_Coupled), 2]
finalDynamics$F2[i] <- out_Coupled[nrow(out_Coupled), 3]
}
#Scatter plot
finalDynamics_long <- gather(finalDynamics, plot, Population, F1:F2, factor_key=TRUE)
finalDynamics_long %>%
ggplot(aes(Parameter_New, Population, color=plot)) +
geom_point(alpha=0.5, size=2) +
labs(y="Population", x="Param Value")
param_seq <- seq(0, 1, by = .05)
finalDynamics <- data.frame(matrix(, nrow = (length(param_seq)), ncol = 3))
colnames(finalDynamics) <- c("Parameter_New", "F1", "F2")
for(i in 1:length(param_seq)){
#Run momdel with each new param combo
#params_test <- params_dispersal
#params_test$i_1 <- param_seq[i]
#params_test$i_2 <- param_seq[i]
params_test <- params_dispersal
params_test$rho_1 <- param_seq[i]
params_test$rho_2 <- param_seq[i]
finalDynamics$Parameter_New[i] <- param_seq[i]
ode(
func=Bauch.Coupled,
y=starting_defaultparams,
times=timespan,
parms=params_test
) %>%
as.data.frame() -> out_Coupled
#Compile output into Dataframe
finalDynamics$F1[i] <- out_Coupled[nrow(out_Coupled), 2]
finalDynamics$F2[i] <- out_Coupled[nrow(out_Coupled), 3]
}
#Scatter plot
finalDynamics_long <- gather(finalDynamics, plot, Population, F1:F2, factor_key=TRUE)
finalDynamics_long %>%
ggplot(aes(Parameter_New, Population, color=plot)) +
geom_point(alpha=0.5, size=2) +
labs(y="Population", x="Param Value")
param_seq <- seq(0, 1, by = .05)
finalDynamics <- data.frame(matrix(, nrow = (length(param_seq)), ncol = 3))
colnames(finalDynamics) <- c("Parameter_New", "F1", "F2")
for(i in 1:length(param_seq)){
#Run momdel with each new param combo
#params_test <- params_dispersal
#params_test$i_1 <- param_seq[i]
#params_test$i_2 <- param_seq[i]
params_test <- params_dispersal
#params_test$rho_1 <- param_seq[i]
params_test$rho_2 <- param_seq[i]
finalDynamics$Parameter_New[i] <- param_seq[i]
ode(
func=Bauch.Coupled,
y=starting_defaultparams,
times=timespan,
parms=params_test
) %>%
as.data.frame() -> out_Coupled
#Compile output into Dataframe
finalDynamics$F1[i] <- out_Coupled[nrow(out_Coupled), 2]
finalDynamics$F2[i] <- out_Coupled[nrow(out_Coupled), 3]
}
#Scatter plot
finalDynamics_long <- gather(finalDynamics, plot, Population, F1:F2, factor_key=TRUE)
finalDynamics_long %>%
ggplot(aes(Parameter_New, Population, color=plot)) +
geom_point(alpha=0.5, size=2) +
labs(y="Population", x="Param Value")
param_seq <- seq(0, 1, by = .05)
finalDynamics <- data.frame(matrix(, nrow = (length(param_seq)), ncol = 3))
colnames(finalDynamics) <- c("Parameter_New", "F1", "F2")
for(i in 1:length(param_seq)){
#Run momdel with each new param combo
params_test <- params_dispersal
params_test$i_1 <- param_seq[i]
#params_test$i_2 <- param_seq[i]
# params_test <- params_dispersal
# params_test$rho_1 <- param_seq[i]
# params_test$rho_2 <- param_seq[i]
finalDynamics$Parameter_New[i] <- param_seq[i]
ode(
func=Bauch.Coupled,
y=starting_defaultparams,
times=timespan,
parms=params_test
) %>%
as.data.frame() -> out_Coupled
#Compile output into Dataframe
finalDynamics$F1[i] <- out_Coupled[nrow(out_Coupled), 2]
finalDynamics$F2[i] <- out_Coupled[nrow(out_Coupled), 3]
}
#Scatter plot
finalDynamics_long <- gather(finalDynamics, plot, Population, F1:F2, factor_key=TRUE)
finalDynamics_long %>%
ggplot(aes(Parameter_New, Population, color=plot)) +
geom_point(alpha=0.5, size=2) +
labs(y="Population", x="Param Value")
knitr::opts_chunk$set(echo = FALSE, warning = FALSE, message = FALSE, dev="cairo_pdf")
library(deSolve)
library(tidyverse)
library(ggplot2)
library(gridExtra)
library(kableExtra)
#library(ODEsensitivity)
library(FME)
#knitr::write_bib look into
setwd("C:/Users/sophi/Documents/GitHub/UNH_Docs/Proposal/Soc_Ecol_Model")
Bauch.Coupled <- function (t, y, params) {
## first extract the state variables
F_1 <- y[1] #Fish Pop var
F_2 <- y[2] #Fish Pop var
X_1 <- y[3] #conservationist var
X_2 <- y[4] #conservationist var
#TT <- y[5]
## now extract the parameters
r_1 <- params["r_1"] # Net growth/fecundity
s_1 <- params["s_1"] # supply and demand
h_1 <- params["h_1"] # Harvesting efficiency
k_1 <- params["k_1"] # Social learning rate
w_1 <- params["w_1"] # conservation costs
c_1 <- params["c_1"] # rarity valuation param
d_1 <- params["d_1"] # social norm strength
r_2 <- params["r_2"] # Net growth/fecundity
s_2 <- params["s_2"] # supply and demand
h_2 <- params["h_2"] # Harvesting efficiency
k_2 <- params["k_2"] # Social learning rate
w_2 <- params["w_2"] # conservation costs
c_2 <- params["c_2"] # rarity valuation param
d_2 <- params["d_2"] # social norm strength
i_1 <- params["i_1"] # Inflow of fish from pop 2 to pop 1
i_2 <- params["i_2"] # Inflow of fish from pop 1 to pop 2
rho_1 <- params["rho_1"] # Influence of pop 2 on pop 1
rho_2 <- params["rho_2"] # Influence of pop 1 on pop 2
## now code the model equations
dF_1dt <-  r_1 * F_1 * (1-F_1) - (h_1 * F_1 * (1-X_1))/(F_1+s_1) - i_2 * F_1 + i_1 * F_2
dF_2dt <-  r_2 * F_2 * (1-F_2) - (h_2 * F_2 * (1-X_2))/(F_2+s_2) - i_1 * F_2 + i_2 * F_1
dX_1dt <- k_1 * X_1 * (1-X_1) *(1/(F_1 + c_1) - w_1 + d_1*(2*X_1 - 1) + rho_1 * (2*X_2 - 1))
dX_2dt <- k_2 * X_2 * (1-X_2) *(1/(F_2 + c_2) - w_2 + d_2*(2*X_2 - 1) + rho_2 * (2*X_1 - 1))
## combine results into a single vector
dydt <- c(dF_1dt, dF_2dt, dX_1dt, dX_2dt)
## return result as a list!
list(dydt)
}
#
# params_Bauch2 <- params_default
#
# times <- timespan
# xstart <- starting_defaultparams # See supplemental data for other starting params
#
# ode(
#   func=Bauch.Coupled,
#   y=xstart,
#   times=times,
#   parms=params_Bauch2
# ) %>%
#   as.data.frame() -> out_Coupled
#
# out_Coupled %>%
#   gather(variable,value,-time) %>%
#   ggplot(aes(x=time,y=value,color=variable))+
#   geom_line(size=1)+
#   theme_classic()+
#   labs(x='time (yr)',y='pop')
param_names <- c("r_1", "s_1", "h_1", "k_1", "w_1", "c_1", "d_1", "i_1", "rho_1",
"r_2", "s_2", "h_2", "k_2", "w_2", "c_2", "d_2", "i_2", "rho_2")
params_dispersal <- data.frame(r_1 = 0.40, s_1 = 0.8, h_1 = 0.25, k_1 = 1.014, w_1 = 0.2, c_1 = 1.5, d_1 = 0.5, i_1 = 0.2, rho_1 = 0.5,
r_2 = 0.35, s_2 = 0.8, h_2 = 0.5, k_2 = 1.014, w_2 = 0.35, c_2 = 1.5, d_2 = 0.5, i_2 = 0.2, rho_2 = 0.5)
# params_default <- data.frame(r_1 = 0.35, s_1 = 0.8, h_1 = 0.5, k_1 = 1.014, w_1 = 0.35, c_1 = 1.5, d_1 = 0.5, i_1 = 0.2, rho_1 = 0.5,
#                              r_2 = 0.35, s_2 = 0.8, h_2 = 0.5, k_2 = 1.014, w_2 = 0.35, c_2 = 1.5, d_2 = 0.5, i_2 = 0.2, rho_2 = 0.5)
starting_defaultparams <- c(F_1 = 0.406, F_2 = 0.406, X_1 = .24, X_2 = .24)
timespan <- seq(from = 0, to = 100, by = .1)
ode(
func=Bauch.Coupled,
y=starting_defaultparams,
times=timespan,
parms=params_dispersal
) %>%
as.data.frame() -> out_Coupled
out_Coupled %>%
gather(variable,value,-time) %>%
ggplot(aes(x=time,y=value,color=variable))+
geom_line(size=1)+
theme_classic()+
labs(x='time (yr)',y='pop')
param_seq <- seq(0, 1, by = .05)
finalDynamics <- data.frame(matrix(, nrow = (length(param_seq)), ncol = 3))
colnames(finalDynamics) <- c("Parameter_New", "F1", "F2")
for(i in 1:length(param_seq)){
#Run momdel with each new param combo
params_test <- params_dispersal
#params_test$i_1 <- param_seq[i]
params_test$i_2 <- param_seq[i]
# params_test <- params_dispersal
# params_test$rho_1 <- param_seq[i]
# params_test$rho_2 <- param_seq[i]
finalDynamics$Parameter_New[i] <- param_seq[i]
ode(
func=Bauch.Coupled,
y=starting_defaultparams,
times=timespan,
parms=params_test
) %>%
as.data.frame() -> out_Coupled
#Compile output into Dataframe
finalDynamics$F1[i] <- out_Coupled[nrow(out_Coupled), 2]
finalDynamics$F2[i] <- out_Coupled[nrow(out_Coupled), 3]
}
#Scatter plot
finalDynamics_long <- gather(finalDynamics, plot, Population, F1:F2, factor_key=TRUE)
finalDynamics_long %>%
ggplot(aes(Parameter_New, Population, color=plot)) +
geom_point(alpha=0.5, size=2) +
labs(y="Population", x="Param Value")
param_seq <- seq(0, 1, by = .05)
finalDynamics <- data.frame(matrix(, nrow = (length(param_seq)), ncol = 3))
colnames(finalDynamics) <- c("Parameter_New", "F1", "F2")
for(i in 1:length(param_seq)){
#Run momdel with each new param combo
params_test <- params_dispersal
params_test$i_1 <- param_seq[i]
params_test$i_2 <- param_seq[i]
# params_test <- params_dispersal
# params_test$rho_1 <- param_seq[i]
# params_test$rho_2 <- param_seq[i]
finalDynamics$Parameter_New[i] <- param_seq[i]
ode(
func=Bauch.Coupled,
y=starting_defaultparams,
times=timespan,
parms=params_test
) %>%
as.data.frame() -> out_Coupled
#Compile output into Dataframe
finalDynamics$F1[i] <- out_Coupled[nrow(out_Coupled), 2]
finalDynamics$F2[i] <- out_Coupled[nrow(out_Coupled), 3]
}
#Scatter plot
finalDynamics_long <- gather(finalDynamics, plot, Population, F1:F2, factor_key=TRUE)
finalDynamics_long %>%
ggplot(aes(Parameter_New, Population, color=plot)) +
geom_point(alpha=0.5, size=2) +
labs(y="Population", x="Param Value")
param_seq <- seq(0, 1, by = .05)
finalDynamics <- data.frame(matrix(, nrow = (length(param_seq)), ncol = 3))
colnames(finalDynamics) <- c("Parameter_New", "F1", "F2")
for(i in 1:length(param_seq)){
#Run momdel with each new param combo
params_test <- params_dispersal
#params_test$i_1 <- param_seq[i]
params_test$i_2 <- param_seq[i]
# params_test <- params_dispersal
# params_test$rho_1 <- param_seq[i]
# params_test$rho_2 <- param_seq[i]
finalDynamics$Parameter_New[i] <- param_seq[i]
ode(
func=Bauch.Coupled,
y=starting_defaultparams,
times=timespan,
parms=params_test
) %>%
as.data.frame() -> out_Coupled
#Compile output into Dataframe
finalDynamics$F1[i] <- out_Coupled[nrow(out_Coupled), 2]
finalDynamics$F2[i] <- out_Coupled[nrow(out_Coupled), 3]
}
#Scatter plot
finalDynamics_long <- gather(finalDynamics, plot, Population, F1:F2, factor_key=TRUE)
finalDynamics_long %>%
ggplot(aes(Parameter_New, Population, color=plot)) +
geom_point(alpha=0.5, size=2) +
labs(y="Population", x="Param Value")
knitr::opts_chunk$set(echo = FALSE, warning = FALSE, message = FALSE)
setwd("C:/Users/sophi/Documents/GitHub/UNH_Docs/Proposal/Soc_Ecol_Model")
library(deSolve)
library(tidyverse)
library(ggplot2)
library(gridExtra)
library(kableExtra)
#library(ODEsensitivity)
library(FME)
param_names <- c("r_1", "s_1", "h_1", "k_1", "w_1", "c_1", "d_1", "i_1", "rho_1",
"r_2", "s_2", "h_2", "k_2", "w_2", "c_2", "d_2", "i_2", "rho_2")
params_default <- data.frame(r_1 = 0.35, s_1 = 0.8, h_1 = 0.5, k_1 = 1.014, w_1 = 0.35, c_1 = 1.5, d_1 = 0.5, i_1 = 0.2, rho_1 = 0.5,
r_2 = 0.35, s_2 = 0.8, h_2 = 0.5, k_2 = 1.014, w_2 = 0.35, c_2 = 1.5, d_2 = 0.5, i_2 = 0.2, rho_2 = 0.5)
starting_defaultparams <- c(F_1 = 0.406, F_2 = 0.406, X_1 = .24, X_2 = .24)
timespan <- seq(from = 0, to = 100, by = .1)
options(tinytex.verbose = TRUE)
giveparams <- data.frame(matrix(, nrow = 9, ncol = 4))
colnames(giveparams) <- c("Parameter", "Population_1", "Population_2", "Def")
giveparams$Parameter <- c("r", "s", "h", "k", "$\\omega$", "c", "d", "i", "$\\rho$")
giveparams$Population_1 <- c(params_default[1:9])
giveparams$Population_2 <- c(params_default[10:18])
giveparams$Def <- c("Fish net growth",
"Supply and demand",
"Harvesting efficiency",
"Social learning rate",
"Conservation cost",
"Rarity valuation",
"Social norm strength (within pop)",
"Fish immigration (from patch)",
"Social norm strength (opposite pop)")
knitr::kable(giveparams, format = "pandoc", booktabs = TRUE, caption = "Default parameter values used in this analysis")
givestart <- data.frame(matrix(, nrow = 2, ncol = 3))
colnames(givestart) <- c("Parameter", "Population_1", "Population_2")
givestart$Parameter <- c("F", "X")
givestart$Population_1 <- c(starting_defaultparams[1], starting_defaultparams[3])
givestart$Population_2 <- c(starting_defaultparams[2], starting_defaultparams[4])
knitr::kable(givestart, format = "latex", booktabs = TRUE, caption = "Starting values used in this analysis")
ModelNoSocial <- function (t, y, params) {
## first extract the state variables
F_1 <- y[1] #Fish Pop var
F_2 <- y[2] #Fish Pop var
#TT <- y[5]
## now extract the parameters
r_1 <- params["r_1"] # Net growth/fecundity
s_1 <- params["s_1"] # supply and demand
h_1 <- params["h_1"] # Harvesting efficiency
r_2 <- params["r_2"] # Net growth/fecundity
s_2 <- params["s_2"] # supply and demand
h_2 <- params["h_2"] # Harvesting efficiency
i_1 <- params["i_1"] # Inflow of fish from pop 2 to pop 1
i_2 <- params["i_2"] # Inflow of fish from pop 1 to pop 2
## now code the model equations
dF_1dt <-  r_1 * F_1 * (1-F_1) - (h_1 * F_1 * 0.50)/(F_1+s_1) - i_2 * F_1 + i_1 * F_2
dF_2dt <-  r_2 * F_2 * (1-F_2) - (h_2 * F_2 * 0.50)/(F_2+s_2) - i_1 * F_2 + i_2 * F_1
## combine results into a single vector
dydt <- c(dF_1dt, dF_2dt)
## return result as a list!
list(dydt)
}
params_Bauch2 <- data.frame(r_1 = params_default$r_1, s_1 = params_default$s_1, h_1 = params_default$h_1, i_1 = params_default$i_1,
r_2 = params_default$r_2, s_2 = params_default$s_2, h_2 = params_default$h_2, i_2 = params_default$i_2)
times <- timespan
xstart <- starting_defaultparams[1:2] # See supplemental data for other starting params
ode(
func=ModelNoSocial,
y=xstart,
times=times,
parms=params_Bauch2
) %>%
as.data.frame() -> out_Coupled
out_Coupled %>%
gather(variable,value,-time) %>%
ggplot(aes(x=time,y=value,color=variable))+
geom_line(size=1)+
theme_classic()+
labs(x='time (yr)',y='pop')
##Maybe see what proportion of people can actually be fishing in this system to make it sustainable
Bauch.Coupled <- function (t, y, params) {
## first extract the state variables
F_1 <- y[1] #Fish Pop var
F_2 <- y[2] #Fish Pop var
X_1 <- y[3] #conservationist var
X_2 <- y[4] #conservationist var
#TT <- y[5]
## now extract the parameters
r_1 <- params["r_1"] # Net growth/fecundity
s_1 <- params["s_1"] # supply and demand
h_1 <- params["h_1"] # Harvesting efficiency
k_1 <- params["k_1"] # Social learning rate
w_1 <- params["w_1"] # conservation costs
c_1 <- params["c_1"] # rarity valuation param
d_1 <- params["d_1"] # social norm strength
r_2 <- params["r_2"] # Net growth/fecundity
s_2 <- params["s_2"] # supply and demand
h_2 <- params["h_2"] # Harvesting efficiency
k_2 <- params["k_2"] # Social learning rate
w_2 <- params["w_2"] # conservation costs
c_2 <- params["c_2"] # rarity valuation param
d_2 <- params["d_2"] # social norm strength
i_1 <- params["i_1"] # Inflow of fish from pop 2 to pop 1
i_2 <- params["i_2"] # Inflow of fish from pop 1 to pop 2
rho_1 <- params["rho_1"] # Influence of pop 2 on pop 1
rho_2 <- params["rho_2"] # Influence of pop 1 on pop 2
## now code the model equations
dF_1dt <-  r_1 * F_1 * (1-F_1) - (h_1 * F_1 * (1-X_1))/(F_1+s_1) - i_2 * F_1 + i_1 * F_2
dF_2dt <-  r_2 * F_2 * (1-F_2) - (h_2 * F_2 * (1-X_2))/(F_2+s_2) - i_1 * F_2 + i_2 * F_1
dX_1dt <- k_1 * X_1 * (1-X_1) *(1/(F_1 + c_1) - w_1 + d_1*(2*X_1 - 1) + rho_1 * (2*X_2 - 1))
dX_2dt <- k_2 * X_2 * (1-X_2) *(1/(F_2 + c_2) - w_2 + d_2*(2*X_2 - 1) + rho_2 * (2*X_1 - 1))
## combine results into a single vector
dydt <- c(dF_1dt, dF_2dt, dX_1dt, dX_2dt)
## return result as a list!
list(dydt)
}
params_Bauch2 <- params_default
times <- timespan
xstart <- starting_defaultparams # See supplemental data for other starting params
ode(
func=Bauch.Coupled,
y=xstart,
times=times,
parms=params_Bauch2
) %>%
as.data.frame() -> out_Coupled
out_Coupled %>%
gather(variable,value,-time) %>%
ggplot(aes(x=time,y=value,color=variable))+
geom_line(size=1)+
theme_classic()+
labs(x='time (yr)',y='pop')
#Ok I have no clue wtf this is telling me
n <- 100 # NUMBER OF SIMULATIONS
param.name <- "w_1" # PARAM TO PERTURB
param.seq <- seq(0,1,length = 50) # RANGE OF PARAMETER
Pars <- params_default
Time <- seq(0, 10, length = n)
State <- starting_defaultparams
param.index <- which(param.name == names(Pars))
out <- list()
for (i in 1:length(param.seq)){
out[[i]] <- matrix(0, n, length(State))}
for (i in 1:length(param.seq)) {
# set params
Pars.loop <- Pars
Pars.loop[param.index] <- param.seq[i]
# converge
init <- ode(State, Time, Bauch.Coupled, Pars.loop)
# get converged points
out[[i]] <- ode(init[n,-1], Time, Bauch.Coupled, Pars.loop)[,-1]
}
range.lim <- lapply(out, function(x) apply(x, 2, range))
range.lim <- apply(do.call("rbind", range.lim), 2, range)
plot.variable <- "F_1" # CHOOSE WHICH VARIABLE TO SHOW
plot(0, 0, pch = "", xlab = param.name, ylab = plot.variable,
xlim = range(param.seq), ylim = range.lim[,plot.variable])
for (i in 1:length(param.seq)) {
points(rep(param.seq[i], n), out[[i]][,plot.variable])
}
BauchSensitivity <- function(pars){
derivs <- function (t, state, pars) {
with (as.list(c(state, pars)), {
## now code the model equations
dF_1dt <-  r_1 * F_1 * (1-F_1) - (h_1 * F_1 * (1-X_1))/(F_1+s_1) - i_2 * F_1 + i_1 * F_2
dF_2dt <-  r_2 * F_2 * (1-F_2) - (h_2 * F_2 * (1-X_2))/(F_2+s_2) - i_1 * F_2 + i_2 * F_1
dX_1dt <- k_1 * X_1 * (1-X_1) *(1/(F_1 + c_1) - w_1 + d_1*(2*X_1 - 1) + rho_1 * (2*X_2 - 1))
dX_2dt <- k_2 * X_2 * (1-X_2) *(1/(F_2 + c_2) - w_2 + d_2*(2*X_2 - 1) + rho_2 * (2*X_1 - 1))
return(list(c(dF_1dt, dF_2dt, dX_1dt, dX_2dt)))
})
}
state   <- starting_defaultparams
tout    <- timespan
## ode solves the model by integration ...
return(as.data.frame(ode(y = state, times = tout, func = derivs,
parms = pars)))
}
SnsBact <- sensFun(func = BauchSensitivity, parms = params_default, sensvar = "F_1", varscale = 1)
summary(SnsBact)
plot(summary(SnsBact))
SnsBact <- sensFun(func = BauchSensitivity, parms = params_default, sensvar = c("F_1", "F_2"), senspar = c("i_1", "i_2", "rho_1", "rho_2"), varscale = 1)
summary(SnsBact)
plot(summary(SnsBact))
plot(summary(SnsBact))
plot(summary(SnsBact))
knitr::opts_chunk$set(echo = FALSE, warning = FALSE, message = FALSE)
setwd("C:/Users/sophi/Documents/GitHub/UNH_Docs/Proposal/Soc_Ecol_Model")
library(deSolve)
library(tidyverse)
library(ggplot2)
library(gridExtra)
library(kableExtra)
#library(ODEsensitivity)
library(FME)
param_names <- c("r_1", "s_1", "h_1", "k_1", "w_1", "c_1", "d_1", "i_1", "rho_1",
"r_2", "s_2", "h_2", "k_2", "w_2", "c_2", "d_2", "i_2", "rho_2")
# params_default <- data.frame(r_1 = 0.35, s_1 = 0.8, h_1 = 0.5, k_1 = 1.014, w_1 = 0.35, c_1 = 1.5, d_1 = 0.5, i_1 = 0.2, rho_1 = 0.5,
#                              r_2 = 0.35, s_2 = 0.8, h_2 = 0.5, k_2 = 1.014, w_2 = 0.35, c_2 = 1.5, d_2 = 0.5, i_2 = 0.2, rho_2 = 0.5)
params_default <- data.frame(r_1 = 0.40, s_1 = 0.8, h_1 = 0.25, k_1 = 1.014, w_1 = 0.2, c_1 = 1.5, d_1 = 0.5, i_1 = 0.2, rho_1 = 0.5,
r_2 = 0.35, s_2 = 0.8, h_2 = 0.5, k_2 = 1.014, w_2 = 0.35, c_2 = 1.5, d_2 = 0.5, i_2 = 0.2, rho_2 = 0.5)
starting_defaultparams <- c(F_1 = 0.406, F_2 = 0.406, X_1 = .24, X_2 = .24)
timespan <- seq(from = 0, to = 100, by = .1)
plot(SnsBact, type = "b", pch = 15:19, col = 2:6,
main = "Sensitivity all vars")
knitr::opts_chunk$set(echo = FALSE, warning = FALSE, message = FALSE)
setwd("C:/Users/sophi/Documents/GitHub/UNH_Docs/Proposal/Soc_Ecol_Model")
library(deSolve)
library(tidyverse)
library(ggplot2)
library(gridExtra)
library(kableExtra)
#library(ODEsensitivity)
library(FME)
param_names <- c("r_1", "s_1", "h_1", "k_1", "w_1", "c_1", "d_1", "i_1", "rho_1",
"r_2", "s_2", "h_2", "k_2", "w_2", "c_2", "d_2", "i_2", "rho_2")
# params_default <- data.frame(r_1 = 0.35, s_1 = 0.8, h_1 = 0.5, k_1 = 1.014, w_1 = 0.35, c_1 = 1.5, d_1 = 0.5, i_1 = 0.2, rho_1 = 0.5,
#                              r_2 = 0.35, s_2 = 0.8, h_2 = 0.5, k_2 = 1.014, w_2 = 0.35, c_2 = 1.5, d_2 = 0.5, i_2 = 0.2, rho_2 = 0.5)
params_default <- data.frame(r_1 = 0.40, s_1 = 0.8, h_1 = 0.25, k_1 = 1.014, w_1 = 0.2, c_1 = 1.5, d_1 = 0.5, i_1 = 0.2, rho_1 = 0.5,
r_2 = 0.35, s_2 = 0.8, h_2 = 0.5, k_2 = 1.014, w_2 = 0.35, c_2 = 1.5, d_2 = 0.5, i_2 = 0.2, rho_2 = 0.5)
starting_defaultparams <- c(F_1 = 0.406, F_2 = 0.406, X_1 = .24, X_2 = .24)
timespan <- seq(from = 0, to = 100, by = .1)
SnsBact <- sensFun(func = BauchSensitivity, parms = params_default, sensvar = c("F_1", "F_2"), senspar = c("i_1", "i_2", "rho_1", "rho_2"), varscale = 1)
SnsBact <- sensFun(func = BauchSensitivity, parms = params_default, sensvar = c("F_1", "F_2"), senspar = c("i_1", "i_2", "rho_1", "rho_2"), varscale = 1)
summary(SnsBact)
plot(summary(SnsBact))
plot(SnsBact, type = "b", pch = 15:19, col = 2:6,
main = "Sensitivity all vars")
SF <- SnsBact <- sensFun(func = BauchSensitivity, parms = params_default, sensvar = c("F_1", "F_2", "X_1", "X_2"), varscale = 1)
summary(SF, var = TRUE)
plot(SF)
plot(SF)
plot(SnsBact, type = "b", pch = 15:19, col = 2:6,
main = "Sensitivity all vars")
SnsBact <- sensFun(func = BauchSensitivity, parms = params_default, sensvar = c("F_1", "F_2"), senspar = c("i_1", "i_2", "rho_1", "rho_2"), varscale = 1)
plot(summary(SnsBact))
plot(SnsBact, type = "b", pch = 15:19, col = 2:6,
main = "Sensitivity all vars")
plot(SnsBact, type = "b", pch = 15:19, col = 2:6,
main = "Sensitivity all vars")
sessionInfo()
