Time <- seq(0, 10, length = n)
State <- xstart
param.index <- which(param.name == names(Pars))
out <- list()
for (i in 1:length(param.seq))
out[[i]] <- matrix(0, n, length(State))
for (i in 1:length(param.seq)) {
# set params
Pars.loop <- Pars
Pars.loop[param.index] <- param.seq[i]
# converge
init <- ode(State, Time, LotVmod, Pars.loop)
# get converged points
out[[i]] <- ode(init[n,-1], Time, LotVmod, Pars.loop)[,-1]
}
#Taken from: https://www.r-bloggers.com/2010/06/r-tools-for-dynamical-systems-bifurcation-plot-in-r%C2%A0for%C2%A0system%C2%A0of%C2%A0odes/
#To avoid confusion, x1 -> x, x2 -> y, f1 -> f, f2 -> g
LotVmod <- function (Time, State, Pars) {
with(as.list(c(State, Pars)), {
dfdt <-  r_1 * f * (1-f) - (h_1 * f * (1-x))/(f+s_1) - i_2 * f + i_1 * g
dgdt <-  r_2 * g * (1-g) - (h_2 * g * (1-y))/(g+s_2) - i_1 * g + i_2 * f
dxdt <- k_1 * x * (1-x) *(1/(f + c_1) - w_1 + d_1*(2*x - 1) + rho_1 * (2*y - 1))
dydt <- k_2 * y * (1-y) *(1/(g + c_2) - w_2 + d_2*(2*y - 1) + rho_2 * (2*x - 1))
return(list(c(df, dg, dx, dy)))
})
}
n <- 100 # number of simulations
param.name <- "rho_1" # choose parameter to perturb
param.seq <- seq(0,1,length = 100) # choose range of parameters
Pars <- c(r_1 = 0.16, s_1 = 0.8, h_1 = .25, k_1 = 0.17, w_1 = 1.44, c_1 = 0.5, d_1 = 0.3, i_1 = 0, rho_1 = 0,
r_2 = 0.16, s_2 = 0.8, h_2 = .25, k_2 = 0.17, w_2 = 1.44, c_2 = 0.5, d_2 = 0.3, i_2 = 0, rho_2 = 0)
Time <- seq(0, 10, length = n)
State <- c(f = 0.406, g = 0.406, x = .24, y = .24)
param.index <- which(param.name == names(Pars))
out <- list()
for (i in 1:length(param.seq))
out[[i]] <- matrix(0, n, length(State))
for (i in 1:length(param.seq)) {
# set params
Pars.loop <- Pars
Pars.loop[param.index] <- param.seq[i]
# converge
init <- ode(State, Time, LotVmod, Pars.loop)
# get converged points
out[[i]] <- ode(init[n,-1], Time, LotVmod, Pars.loop)[,-1]
}
out
range.lim <- lapply(out, function(x) apply(x, 2, range))
range.lin
range.lim
#Taken from: https://www.r-bloggers.com/2010/06/r-tools-for-dynamical-systems-bifurcation-plot-in-r%C2%A0for%C2%A0system%C2%A0of%C2%A0odes/
#To avoid confusion, x1 -> x, x2 -> y, f1 -> f, f2 -> g
LotVmod <- function (Time, State, Pars) {
with(as.list(c(State, Pars)), {
dfdt <-  r_1 * f * (1-f) - (h_1 * f * (1-x))/(f+s_1) - i_2 * f + i_1 * g
dgdt <-  r_2 * g * (1-g) - (h_2 * g * (1-y))/(g+s_2) - i_1 * g + i_2 * f
dxdt <- k_1 * x * (1-x) *(1/(f + c_1) - w_1 + d_1*(2*x - 1) + rho_1 * (2*y - 1))
dydt <- k_2 * y * (1-y) *(1/(g + c_2) - w_2 + d_2*(2*y - 1) + rho_2 * (2*x - 1))
return(list(c(df, dg, dx, dy)))
})
}
n <- 100 # number of simulations
param.name <- "rho_1" # choose parameter to perturb
param.seq <- seq(0,1,length = 50) # choose range of parameters
Pars <- c(r_1 = 0.16, s_1 = 0.8, h_1 = .25, k_1 = 0.17, w_1 = 1.44, c_1 = 0.5, d_1 = 0.3, i_1 = 0, rho_1 = 0,
r_2 = 0.16, s_2 = 0.8, h_2 = .25, k_2 = 0.17, w_2 = 1.44, c_2 = 0.5, d_2 = 0.3, i_2 = 0, rho_2 = 0)
Time <- seq(0, 10, length = n)
State <- c(f = 0.406, g = 0.406, x = .24, y = .24)
param.index <- which(param.name == names(Pars))
out <- list()
for (i in 1:length(param.seq))
out[[i]] <- matrix(0, n, length(State))
for (i in 1:length(param.seq)) {
# set params
Pars.loop <- Pars
Pars.loop[param.index] <- param.seq[i]
# converge
init <- ode(State, Time, LotVmod, Pars.loop)
# get converged points
out[[i]] <- ode(init[n,-1], Time, LotVmod, Pars.loop)[,-1]
}
knitr::opts_chunk$set(echo = FALSE, warning = FALSE, message = FALSE)
setwd("C:/Users/Sophi/Documents/GitHub/UNH_Docs/Proposal/Soc_Ecol_Model")
library(deSolve)
library(tidyverse)
library(ggplot2)
library(gridExtra)
library(kableExtra)
#Nest try h = .25
params_list <- data.frame(r_1 = 0.16, s_1 = 0.8, h_1 = .25, k_1 = 0.17, w_1 = 1.44, c_1 = 0.5, d_1 = 0.3, i_1 = 0, rho_1 = 0,
r_2 = 0.16, s_2 = 0.8, h_2 = .25, k_2 = 0.17, w_2 = 1.44, c_2 = 0.5, d_2 = 0.3, i_2 = 0, rho_2 = 0)
# #WORKED - MINIMUM GROWTH RATE USED IN THAMPI
# params_list <- data.frame(r_1 = 0.16, s_1 = 0.8, h_1 = 0.5, k_1 = 0.17, w_1 = 1.44, c_1 = 0.6, d_1 = 0.3, i_1 = 0, rho_1 = 0,
#                           r_2 = 0.16, s_2 = 0.8, h_2 = 0.5, k_2 = 0.17, w_2 = 1.44, c_2 = 0.6, d_2 = 0.3, i_2 = 0, rho_2 = 0)
#Extensions of Bauch Default but with my params I want changed. Goal: get this to oscillate
# params_list <- data.frame(r_1 = 0.35, s_1 = 0.8, h_1 = 0.5, k_1 = 0.17, w_1 = 1, c_1 = 1.68, d_1 = 0.3, i_1 = 0, rho_1 = 0,
#                           r_2 = 0.35, s_2 = 0.8, h_2 = 0.5, k_2 = 0.17, w_2 = 1, c_2 = 1.68, d_2 = 0.3, i_2 = 0, rho_2 = 0)
#Extension of Bauch Default
# params_list <- data.frame(r_1 = 0.06, s_1 = 0.8, h_1 = 0.1, k_1 = 0.17, w_1 = 1, c_1 = 0.6, d_1 = 0.3, i_1 = 0, rho_1 = 0,
#                           r_2 = 0.06, s_2 = 0.8, h_2 = 0.1, k_2 = 0.17, w_2 = 1, c_2 = 0.6, d_2 = 0.3, i_2 = 0, rho_2 = 0)
xstart <- c(F_1 = 0.406, F_2 = 0.406, X_1 = .24, X_2 = .24)
timespan <- seq(from = 0, to = 1000, by = 1)
#Taken from: https://www.r-bloggers.com/2010/06/r-tools-for-dynamical-systems-bifurcation-plot-in-r%C2%A0for%C2%A0system%C2%A0of%C2%A0odes/
#To avoid confusion, x1 -> x, x2 -> y, f1 -> f, f2 -> g
LotVmod <- function (Time, State, Pars) {
with(as.list(c(State, Pars)), {
dfdt <-  r_1 * f * (1-f) - (h_1 * f * (1-x))/(f+s_1) - i_2 * f + i_1 * g
dgdt <-  r_2 * g * (1-g) - (h_2 * g * (1-y))/(g+s_2) - i_1 * g + i_2 * f
dxdt <- k_1 * x * (1-x) *(1/(f + c_1) - w_1 + d_1*(2*x - 1) + rho_1 * (2*y - 1))
dydt <- k_2 * y * (1-y) *(1/(g + c_2) - w_2 + d_2*(2*y - 1) + rho_2 * (2*x - 1))
return(list(c(df, dg, dx, dy)))
})
}
n <- 100 # number of simulations
param.name <- "rho_1" # choose parameter to perturb
param.seq <- seq(0,1,length = 50) # choose range of parameters
Pars <- c(r_1 = 0.16, s_1 = 0.8, h_1 = .25, k_1 = 0.17, w_1 = 1.44, c_1 = 0.5, d_1 = 0.3, i_1 = 0, rho_1 = 0,
r_2 = 0.16, s_2 = 0.8, h_2 = .25, k_2 = 0.17, w_2 = 1.44, c_2 = 0.5, d_2 = 0.3, i_2 = 0, rho_2 = 0)
Time <- seq(0, 10, length = n)
State <- c(f = 0.406, g = 0.406, x = .24, y = .24)
param.index <- which(param.name == names(Pars))
out <- list()
for (i in 1:length(param.seq))
out[[i]] <- matrix(0, n, length(State))
for (i in 1:length(param.seq)) {
# set params
Pars.loop <- Pars
Pars.loop[param.index] <- param.seq[i]
# converge
init <- ode(State, Time, LotVmod, Pars.loop)
# get converged points
out[[i]] <- ode(init[n,-1], Time, LotVmod, Pars.loop)[,-1]
}
LotVmod <- function (Time, State, Pars) {
with(as.list(c(State, Pars)), {
dx = x*(alpha - beta*y)
dy = -y*(gamma - delta*x)
return(list(c(dx, dy)))
})
}
n <- 100 # number of simulations
param.name <- "gamma" # choose parameter to perturb
param.seq <- seq(0,1,length = 50) # choose range of parameters
Pars <- c(alpha = 1, beta = .001, gamma = 1, delta = .001)
Time <- seq(0, 10, length = n)
State <- c(x = .5, y = .9)
param.index <- which(param.name == names(Pars))
out <- list()
for (i in 1:length(param.seq))
out[[i]] <- matrix(0, n, length(State))
for (i in 1:length(param.seq)) {
# set params
Pars.loop <- Pars
Pars.loop[param.index] <- param.seq[i]
# converge
init <- ode(State, Time, LotVmod, Pars.loop)
# get converged points
out[[i]] <- ode(init[n,-1], Time, LotVmod, Pars.loop)[,-1]
}
range.lim <- lapply(out, function(x) apply(x, 2, range))
range.lim <- apply(do.call("rbind", range.lim), 2, range)
plot.variable <- "x" # choose which variable to show
plot(0, 0, pch = "", xlab = param.name, ylab = plot.variable,
xlim = range(param.seq), ylim = range.lim[,plot.variable])
for (i in 1:length(param.seq)) {
points(rep(param.seq[i], n), out[[i]][,plot.variable])
}
out
knitr::opts_chunk$set(echo = FALSE, warning = FALSE, message = FALSE)
setwd("C:/Users/Sophi/Documents/GitHub/UNH_Docs/Proposal/Soc_Ecol_Model")
library(deSolve)
library(tidyverse)
library(ggplot2)
library(gridExtra)
library(kableExtra)
#Nest try h = .25
params_list <- data.frame(r_1 = 0.16, s_1 = 0.8, h_1 = .25, k_1 = 0.17, w_1 = 1.44, c_1 = 0.5, d_1 = 0.3, i_1 = 0, rho_1 = 0,
r_2 = 0.16, s_2 = 0.8, h_2 = .25, k_2 = 0.17, w_2 = 1.44, c_2 = 0.5, d_2 = 0.3, i_2 = 0, rho_2 = 0)
# #WORKED - MINIMUM GROWTH RATE USED IN THAMPI
# params_list <- data.frame(r_1 = 0.16, s_1 = 0.8, h_1 = 0.5, k_1 = 0.17, w_1 = 1.44, c_1 = 0.6, d_1 = 0.3, i_1 = 0, rho_1 = 0,
#                           r_2 = 0.16, s_2 = 0.8, h_2 = 0.5, k_2 = 0.17, w_2 = 1.44, c_2 = 0.6, d_2 = 0.3, i_2 = 0, rho_2 = 0)
#Extensions of Bauch Default but with my params I want changed. Goal: get this to oscillate
# params_list <- data.frame(r_1 = 0.35, s_1 = 0.8, h_1 = 0.5, k_1 = 0.17, w_1 = 1, c_1 = 1.68, d_1 = 0.3, i_1 = 0, rho_1 = 0,
#                           r_2 = 0.35, s_2 = 0.8, h_2 = 0.5, k_2 = 0.17, w_2 = 1, c_2 = 1.68, d_2 = 0.3, i_2 = 0, rho_2 = 0)
#Extension of Bauch Default
# params_list <- data.frame(r_1 = 0.06, s_1 = 0.8, h_1 = 0.1, k_1 = 0.17, w_1 = 1, c_1 = 0.6, d_1 = 0.3, i_1 = 0, rho_1 = 0,
#                           r_2 = 0.06, s_2 = 0.8, h_2 = 0.1, k_2 = 0.17, w_2 = 1, c_2 = 0.6, d_2 = 0.3, i_2 = 0, rho_2 = 0)
xstart <- c(F_1 = 0.406, F_2 = 0.406, X_1 = .24, X_2 = .24)
timespan <- seq(from = 0, to = 1000, by = 1)
#Taken from: https://www.r-bloggers.com/2010/06/r-tools-for-dynamical-systems-bifurcation-plot-in-r%C2%A0for%C2%A0system%C2%A0of%C2%A0odes/
#To avoid confusion, x1 -> x, x2 -> y, f1 -> f, f2 -> g
LotVmod <- function (Time, State, Pars) {
with(as.list(c(State, Pars)), {
dfdt <-  r_1 * f * (1-f) - (h_1 * f * (1-x))/(f+s_1) - i_2 * f + i_1 * g
dgdt <-  r_2 * g * (1-g) - (h_2 * g * (1-y))/(g+s_2) - i_1 * g + i_2 * f
dxdt <- k_1 * x * (1-x) *(1/(f + c_1) - w_1 + d_1*(2*x - 1) + rho_1 * (2*y - 1))
dydt <- k_2 * y * (1-y) *(1/(g + c_2) - w_2 + d_2*(2*y - 1) + rho_2 * (2*x - 1))
return(list(c(df, dg, dx, dy)))
})
}
n <- 100 # number of simulations
param.name <- "rho_1" # choose parameter to perturb
param.seq <- seq(0,1,length = 50) # choose range of parameters
Pars <- c(r_1 = 0.16, s_1 = 0.8, h_1 = .25, k_1 = 0.17, w_1 = 1.44, c_1 = 0.5, d_1 = 0.3, i_1 = 0, rho_1 = 0,
r_2 = 0.16, s_2 = 0.8, h_2 = .25, k_2 = 0.17, w_2 = 1.44, c_2 = 0.5, d_2 = 0.3, i_2 = 0, rho_2 = 0)
Time <- seq(0, 10, length = n)
State <- c(f = 0.406, g = 0.406, x = .24, y = .24)
param.index <- which(param.name == names(Pars))
out <- list()
for (i in 1:length(param.seq))
out[[i]] <- matrix(0, n, length(State))
for (i in 1:length(param.seq)) {
# set params
Pars.loop <- Pars
Pars.loop[param.index] <- param.seq[i]
# converge
init <- ode(State, Time, LotVmod, Pars.loop)
# get converged points
out[[i]] <- ode(init[n,-1], Time, LotVmod, Pars.loop)[,-1]
}
out
length(param.seq)
i <- 1
# set params
Pars.loop <- Pars
Pars.loop[param.index] <- param.seq[i]
# converge
init <- ode(State, Time, LotVmod, Pars.loop)
?ode
#Taken from: https://www.r-bloggers.com/2010/06/r-tools-for-dynamical-systems-bifurcation-plot-in-r%C2%A0for%C2%A0system%C2%A0of%C2%A0odes/
#To avoid confusion, x1 -> x, x2 -> y, f1 -> f, f2 -> g
LotVmod <- function (Time, State, Pars) {
with(as.list(c(State, Pars)), {
dfdt <-  r_1 * f * (1-f) - (h_1 * f * (1-x))/(f+s_1) - i_2 * f + i_1 * g
dgdt <-  r_2 * g * (1-g) - (h_2 * g * (1-y))/(g+s_2) - i_1 * g + i_2 * f
dxdt <- k_1 * x * (1-x) *(1/(f + c_1) - w_1 + d_1*(2*x - 1) + rho_1 * (2*y - 1))
dydt <- k_2 * y * (1-y) *(1/(g + c_2) - w_2 + d_2*(2*y - 1) + rho_2 * (2*x - 1))
return(list(c(df, dg, dx, dy)))
})
}
n <- 100 # number of simulations
param.name <- "rho_1" # choose parameter to perturb
param.seq <- seq(0,1,length = 50) # choose range of parameters
Pars <- c(r_1 = 0.16, s_1 = 0.8, h_1 = .25, k_1 = 0.17, w_1 = 1.44, c_1 = 0.5, d_1 = 0.3, i_1 = 0, rho_1 = 0,
r_2 = 0.16, s_2 = 0.8, h_2 = .25, k_2 = 0.17, w_2 = 1.44, c_2 = 0.5, d_2 = 0.3, i_2 = 0, rho_2 = 0)
Time <- seq(0, 10, length = n)
State <- c(f = 0.406, g = 0.406, x = .24, y = .24)
param.index <- which(param.name == names(Pars))
out <- list()
for (i in 1:length(param.seq))
out[[i]] <- matrix(0, n, length(State))
for (i in 1:length(param.seq)) {
# set params
Pars.loop <- Pars
Pars.loop[param.index] <- param.seq[i]
# converge
init <- ode(State, Time, LotVmod, Pars.loop)
# get converged points
out[[i]] <- ode(init[n,-1], Time, LotVmod, Pars.loop)[,-1]
}
traceback()
# set params
Pars.loop <- Pars
Pars.loop
knitr::opts_chunk$set(echo = FALSE, warning = FALSE, message = FALSE)
setwd("C:/Users/Sophi/Documents/GitHub/UNH_Docs/Proposal/Soc_Ecol_Model")
library(deSolve)
library(tidyverse)
library(ggplot2)
library(gridExtra)
library(kableExtra)
#Nest try h = .25
params_list <- data.frame(r_1 = 0.16, s_1 = 0.8, h_1 = .25, k_1 = 0.17, w_1 = 1.44, c_1 = 0.5, d_1 = 0.3, i_1 = 0, rho_1 = 0,
r_2 = 0.16, s_2 = 0.8, h_2 = .25, k_2 = 0.17, w_2 = 1.44, c_2 = 0.5, d_2 = 0.3, i_2 = 0, rho_2 = 0)
# #WORKED - MINIMUM GROWTH RATE USED IN THAMPI
# params_list <- data.frame(r_1 = 0.16, s_1 = 0.8, h_1 = 0.5, k_1 = 0.17, w_1 = 1.44, c_1 = 0.6, d_1 = 0.3, i_1 = 0, rho_1 = 0,
#                           r_2 = 0.16, s_2 = 0.8, h_2 = 0.5, k_2 = 0.17, w_2 = 1.44, c_2 = 0.6, d_2 = 0.3, i_2 = 0, rho_2 = 0)
#Extensions of Bauch Default but with my params I want changed. Goal: get this to oscillate
# params_list <- data.frame(r_1 = 0.35, s_1 = 0.8, h_1 = 0.5, k_1 = 0.17, w_1 = 1, c_1 = 1.68, d_1 = 0.3, i_1 = 0, rho_1 = 0,
#                           r_2 = 0.35, s_2 = 0.8, h_2 = 0.5, k_2 = 0.17, w_2 = 1, c_2 = 1.68, d_2 = 0.3, i_2 = 0, rho_2 = 0)
#Extension of Bauch Default
# params_list <- data.frame(r_1 = 0.06, s_1 = 0.8, h_1 = 0.1, k_1 = 0.17, w_1 = 1, c_1 = 0.6, d_1 = 0.3, i_1 = 0, rho_1 = 0,
#                           r_2 = 0.06, s_2 = 0.8, h_2 = 0.1, k_2 = 0.17, w_2 = 1, c_2 = 0.6, d_2 = 0.3, i_2 = 0, rho_2 = 0)
xstart <- c(F_1 = 0.406, F_2 = 0.406, X_1 = .24, X_2 = .24)
timespan <- seq(from = 0, to = 1000, by = 1)
#Taken from: https://www.r-bloggers.com/2010/06/r-tools-for-dynamical-systems-bifurcation-plot-in-r%C2%A0for%C2%A0system%C2%A0of%C2%A0odes/
#To avoid confusion, x1 -> x, x2 -> y, f1 -> f, f2 -> g
LotVmod <- function (Time, State, Pars) {
with(as.list(c(State, Pars)), {
dfdt <-  r_1 * f * (1-f) - (h_1 * f * (1-x))/(f+s_1) - i_2 * f + i_1 * g
dgdt <-  r_2 * g * (1-g) - (h_2 * g * (1-y))/(g+s_2) - i_1 * g + i_2 * f
dxdt <- k_1 * x * (1-x) *(1/(f + c_1) - w_1 + d_1*(2*x - 1) + rho_1 * (2*y - 1))
dydt <- k_2 * y * (1-y) *(1/(g + c_2) - w_2 + d_2*(2*y - 1) + rho_2 * (2*x - 1))
return(list(c(df, dg, dx, dy)))
})
}
n <- 100 # number of simulations
param.name <- "rho_1" # choose parameter to perturb
param.seq <- seq(0,1,length = 50) # choose range of parameters
Pars <- c(r_1 = 0.16, s_1 = 0.8, h_1 = .25, k_1 = 0.17, w_1 = 1.44, c_1 = 0.5, d_1 = 0.3, i_1 = 0, rho_1 = 0,
r_2 = 0.16, s_2 = 0.8, h_2 = .25, k_2 = 0.17, w_2 = 1.44, c_2 = 0.5, d_2 = 0.3, i_2 = 0, rho_2 = 0)
Time <- seq(0, 10, length = n)
State <- c(f = 0.406, g = 0.406, x = .24, y = .24)
param.index <- which(param.name == names(Pars))
out <- list()
for (i in 1:length(param.seq))
out[[i]] <- matrix(0, n, length(State))
for (i in 1:length(param.seq)) {
# set params
Pars.loop <- Pars
Pars.loop[param.index] <- param.seq[i]
# converge
init <- ode(State, Time, LotVmod, Pars.loop)
# get converged points
out[[i]] <- ode(init[n,-1], Time, LotVmod, Pars.loop)[,-1]
}
traceback()
ode(State, Time, LotVmod, Pars.loop)
out
LotVmod <- function (Time, State, Pars) {
with(as.list(c(State, Pars)), {
dx = x*(alpha - beta*y)
dy = -y*(gamma - delta*x)
return(list(c(dx, dy)))
})
}
n <- 100 # number of simulations
param.name <- "gamma" # choose parameter to perturb
param.seq <- seq(0,1,length = 50) # choose range of parameters
Pars <- c(alpha = 1, beta = .001, gamma = 1, delta = .001)
Time <- seq(0, 10, length = n)
State <- c(x = .5, y = .9)
param.index <- which(param.name == names(Pars))
out <- list()
for (i in 1:length(param.seq))
out[[i]] <- matrix(0, n, length(State))
out
#To avoid confusion, x1 -> x, x2 -> y, f1 -> f, f2 -> g
LotVmod <- function (Time, State, Pars) {
with(as.list(c(State, Pars)), {
dfdt <-  r_1 * f * (1-f) - (h_1 * f * (1-x))/(f+s_1) - i_2 * f + i_1 * g
dgdt <-  r_2 * g * (1-g) - (h_2 * g * (1-y))/(g+s_2) - i_1 * g + i_2 * f
dxdt <- k_1 * x * (1-x) *(1/(f + c_1) - w_1 + d_1*(2*x - 1) + rho_1 * (2*y - 1))
dydt <- k_2 * y * (1-y) *(1/(g + c_2) - w_2 + d_2*(2*y - 1) + rho_2 * (2*x - 1))
return(list(c(df, dg, dx, dy)))
})
}
n <- 100 # number of simulations
param.name <- "rho_1" # choose parameter to perturb
param.seq <- seq(0,1,length = 50) # choose range of parameters
Pars <- c(r_1 = 0.16, s_1 = 0.8, h_1 = .25, k_1 = 0.17, w_1 = 1.44, c_1 = 0.5, d_1 = 0.3, i_1 = 0, rho_1 = 0,
r_2 = 0.16, s_2 = 0.8, h_2 = .25, k_2 = 0.17, w_2 = 1.44, c_2 = 0.5, d_2 = 0.3, i_2 = 0, rho_2 = 0)
Time <- seq(0, 10, length = n)
State <- c(f = 0.406, g = 0.406, x = .24, y = .24)
param.index <- which(param.name == names(Pars))
out <- list()
for (i in 1:length(param.seq))
out[[i]] <- matrix(0, n, length(State))
out
#Taken from: https://www.r-bloggers.com/2010/06/r-tools-for-dynamical-systems-bifurcation-plot-in-r%C2%A0for%C2%A0system%C2%A0of%C2%A0odes/
#To avoid confusion, x1 -> x, x2 -> y, f1 -> f, f2 -> g
# Bauch.Coupled <- function (Time, State, Pars) {
#   with(as.list(c(State, Pars)), {
#     dfdt <-  r_1 * f * (1-f) - (h_1 * f * (1-x))/(f+s_1) - i_2 * f + i_1 * g
#     dgdt <-  r_2 * g * (1-g) - (h_2 * g * (1-y))/(g+s_2) - i_1 * g + i_2 * f
#
#     dxdt <- k_1 * x * (1-x) *(1/(f + c_1) - w_1 + d_1*(2*x - 1) + rho_1 * (2*y - 1))
#     dydt <- k_2 * y * (1-y) *(1/(g + c_2) - w_2 + d_2*(2*y - 1) + rho_2 * (2*x - 1))
#
#     return(list(c(df, dg, dx, dy)))
#   })
# }
n <- 100 # number of simulations
param.name <- "rho_1" # choose parameter to perturb
param.seq <- seq(0,1,length = 50) # choose range of parameters
Pars <- c(r_1 = 0.16, s_1 = 0.8, h_1 = .25, k_1 = 0.17, w_1 = 1.44, c_1 = 0.5, d_1 = 0.3, i_1 = 0, rho_1 = 0,
r_2 = 0.16, s_2 = 0.8, h_2 = .25, k_2 = 0.17, w_2 = 1.44, c_2 = 0.5, d_2 = 0.3, i_2 = 0, rho_2 = 0)
Time <- seq(0, 10, length = n)
State <- c(F_1 = 0.406, F_2 = 0.406, X_1 = .24, X_2 = .24)
param.index <- which(param.name == names(Pars))
out <- list()
for (i in 1:length(param.seq))
out[[i]] <- matrix(0, n, length(State))
for (i in 1:length(param.seq)) {
# set params
Pars.loop <- Pars
Pars.loop[param.index] <- param.seq[i]
# converge
init <- ode(State, Time, Bauch.Coupled, Pars.loop)
# get converged points
out[[i]] <- ode(init[n,-1], Time, Bauch.Coupled, Pars.loop)[,-1]
}
##Maybe see what proportion of people can actually be fishing in this system to make it sustainable
Bauch.Coupled <- function (t, y, params) {
## first extract the state variables
F_1 <- y[1] #Fish Pop var
F_2 <- y[2] #Fish Pop var
X_1 <- y[3] #conservationist var
X_2 <- y[4] #conservationist var
#TT <- y[5]
## now extract the parameters
r_1 <- params["r_1"] # Net growth/fecundity
s_1 <- params["s_1"] # supply and demand
h_1 <- params["h_1"] # Harvesting efficiency
k_1 <- params["k_1"] # Social learning rate
w_1 <- params["w_1"] # conservation costs
c_1 <- params["c_1"] # rarity valuation param
d_1 <- params["d_1"] # social norm strength
i_1 <- params["i_1"] # Inflow of fish from pop 2 to pop 1
rho_1 <- params["rho_1"] # Influence of pop 2 on pop 1
r_2 <- params["r_2"] # Net growth/fecundity
s_2 <- params["s_2"] # supply and demand
h_2 <- params["h_2"] # Harvesting efficiency
k_2 <- params["k_2"] # Social learning rate
w_2 <- params["w_2"] # conservation costs
c_2 <- params["c_2"] # rarity valuation param
d_2 <- params["d_2"] # social norm strength
i_2 <- params["i_2"] # Inflow of fish from pop 1 to pop 2
rho_2 <- params["rho_2"] # Influence of pop 1 on pop 2
## now code the model equations
dF_1dt <-  r_1 * F_1 * (1-F_1) - (h_1 * F_1 * (1-X_1))/(F_1+s_1) - i_2 * F_1 + i_1 * F_2
dF_2dt <-  r_2 * F_2 * (1-F_2) - (h_2 * F_2 * (1-X_2))/(F_2+s_2) - i_1 * F_2 + i_2 * F_1
dX_1dt <- k_1 * X_1 * (1-X_1) *(1/(F_1 + c_1) - w_1 + d_1*(2*X_1 - 1) + rho_1 * (2*X_2 - 1))
dX_2dt <- k_2 * X_2 * (1-X_2) *(1/(F_2 + c_2) - w_2 + d_2*(2*X_2 - 1) + rho_2 * (2*X_1 - 1))
## combine results into a single vector
dydt <- c(dF_1dt, dF_2dt, dX_1dt, dX_2dt)
## return result as a list!
list(dydt)
}
params_Bauch2 <- params_list
#Taken from: https://www.r-bloggers.com/2010/06/r-tools-for-dynamical-systems-bifurcation-plot-in-r%C2%A0for%C2%A0system%C2%A0of%C2%A0odes/
#To avoid confusion, x1 -> x, x2 -> y, f1 -> f, f2 -> g
# Bauch.Coupled <- function (Time, State, Pars) {
#   with(as.list(c(State, Pars)), {
#     dfdt <-  r_1 * f * (1-f) - (h_1 * f * (1-x))/(f+s_1) - i_2 * f + i_1 * g
#     dgdt <-  r_2 * g * (1-g) - (h_2 * g * (1-y))/(g+s_2) - i_1 * g + i_2 * f
#
#     dxdt <- k_1 * x * (1-x) *(1/(f + c_1) - w_1 + d_1*(2*x - 1) + rho_1 * (2*y - 1))
#     dydt <- k_2 * y * (1-y) *(1/(g + c_2) - w_2 + d_2*(2*y - 1) + rho_2 * (2*x - 1))
#
#     return(list(c(df, dg, dx, dy)))
#   })
# }
n <- 100 # number of simulations
param.name <- "rho_1" # choose parameter to perturb
param.seq <- seq(0,1,length = 50) # choose range of parameters
Pars <- c(r_1 = 0.16, s_1 = 0.8, h_1 = .25, k_1 = 0.17, w_1 = 1.44, c_1 = 0.5, d_1 = 0.3, i_1 = 0, rho_1 = 0,
r_2 = 0.16, s_2 = 0.8, h_2 = .25, k_2 = 0.17, w_2 = 1.44, c_2 = 0.5, d_2 = 0.3, i_2 = 0, rho_2 = 0)
Time <- seq(0, 10, length = n)
State <- c(F_1 = 0.406, F_2 = 0.406, X_1 = .24, X_2 = .24)
param.index <- which(param.name == names(Pars))
out <- list()
for (i in 1:length(param.seq))
out[[i]] <- matrix(0, n, length(State))
for (i in 1:length(param.seq)) {
# set params
Pars.loop <- Pars
Pars.loop[param.index] <- param.seq[i]
# converge
init <- ode(State, Time, Bauch.Coupled, Pars.loop)
# get converged points
out[[i]] <- ode(init[n,-1], Time, Bauch.Coupled, Pars.loop)[,-1]
}
range.lim <- lapply(out, function(x) apply(x, 2, range))
range.lim <- apply(do.call("rbind", range.lim), 2, range)
plot.variable <- "X_1" # choose which variable to show
plot(0, 0, pch = "", xlab = param.name, ylab = plot.variable,
xlim = range(param.seq), ylim = range.lim[,plot.variable])
for (i in 1:length(param.seq)) {
points(rep(param.seq[i], n), out[[i]][,plot.variable])
}
#Taken from: https://www.r-bloggers.com/2010/06/r-tools-for-dynamical-systems-bifurcation-plot-in-r%C2%A0for%C2%A0system%C2%A0of%C2%A0odes/
#To avoid confusion, x1 -> x, x2 -> y, f1 -> f, f2 -> g
# Bauch.Coupled <- function (Time, State, Pars) {
#   with(as.list(c(State, Pars)), {
#     dfdt <-  r_1 * f * (1-f) - (h_1 * f * (1-x))/(f+s_1) - i_2 * f + i_1 * g
#     dgdt <-  r_2 * g * (1-g) - (h_2 * g * (1-y))/(g+s_2) - i_1 * g + i_2 * f
#
#     dxdt <- k_1 * x * (1-x) *(1/(f + c_1) - w_1 + d_1*(2*x - 1) + rho_1 * (2*y - 1))
#     dydt <- k_2 * y * (1-y) *(1/(g + c_2) - w_2 + d_2*(2*y - 1) + rho_2 * (2*x - 1))
#
#     return(list(c(df, dg, dx, dy)))
#   })
# }
n <- 100 # number of simulations
param.name <- "i_2" # choose parameter to perturb
param.seq <- seq(0,1,length = 50) # choose range of parameters
Pars <- c(r_1 = 0.16, s_1 = 0.8, h_1 = .25, k_1 = 0.17, w_1 = 1.44, c_1 = 0.5, d_1 = 0.3, i_1 = 0, rho_1 = 0,
r_2 = 0.16, s_2 = 0.8, h_2 = .25, k_2 = 0.17, w_2 = 1.44, c_2 = 0.5, d_2 = 0.3, i_2 = 0, rho_2 = 0)
Time <- seq(0, 10, length = n)
State <- c(F_1 = 0.406, F_2 = 0.406, X_1 = .24, X_2 = .24)
param.index <- which(param.name == names(Pars))
out <- list()
for (i in 1:length(param.seq))
out[[i]] <- matrix(0, n, length(State))
for (i in 1:length(param.seq)) {
# set params
Pars.loop <- Pars
Pars.loop[param.index] <- param.seq[i]
# converge
init <- ode(State, Time, Bauch.Coupled, Pars.loop)
# get converged points
out[[i]] <- ode(init[n,-1], Time, Bauch.Coupled, Pars.loop)[,-1]
}
range.lim <- lapply(out, function(x) apply(x, 2, range))
range.lim <- apply(do.call("rbind", range.lim), 2, range)
plot.variable <- "F_1" # choose which variable to show
plot(0, 0, pch = "", xlab = param.name, ylab = plot.variable,
xlim = range(param.seq), ylim = range.lim[,plot.variable])
for (i in 1:length(param.seq)) {
points(rep(param.seq[i], n), out[[i]][,plot.variable])
}
