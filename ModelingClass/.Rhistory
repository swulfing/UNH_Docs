#Make a variable for cover of branching corals. Filter ACB
CB_dat <- filter(bendat, code %in% c("ACB", "CB"))
soft_dat <- bendat %>%
filter(code %in% c("S", "SI")) %>% #Sand or Silt
group_by(site) %>%
summarize(soft_cover = sum(cover),
n_pts = mean(n_pts))
#Now join fish and benthic dataframes
nrow(dat)
dat2 <- left_join(dat, CB_dat, by = "site")
nrow(dat2)
#Make a variable for cover of branching corals. Filter ACB or CB
CB_dat <- filter(bendat, code %in% c("ACB", "CB"))
soft_dat <- bendat %>%
filter(code %in% c("S", "SI")) %>% #Sand or Silt
group_by(site) %>%
summarize(soft_cover = sum(cover),
n_pts = mean(n_pts))
#Now join fish and benthic dataframes
nrow(dat)
dat2 <- left_join(dat, CB_dat, by = "site")
nrow(dat2)
View(CB_dat)
View(dat)
View(dat2)
nrow(CB_dat)
dat2 <- left_join(dat2, soft_dat, by = c("site", "n_pts"))
nrow(dat2)
#summarize over two benthic categories
CB_dat <- group_by(CB_dat, site)
CB_dat <- summarize(CB_dat, CB_cover = sum(cover),
n_pts = mean(n_pts))
soft_dat <- bendat %>%
filter(code %in% c("S", "SI")) %>% #Sand or Silt
group_by(site) %>%
summarize(soft_cover = sum(cover),
n_pts = mean(n_pts))
#Now join fish and benthic dataframes
nrow(dat)
dat2 <- left_join(dat, CB_dat, by = "site")
nrow(dat2)
dat2 <- left_join(dat2, soft_dat, by = c("site", "n_pts"))
nrow(dat2)
ggplot(dat2) +
aes(x = logged, y = CB_cover) +
geom_boxplot()
ggplot(dat2) +
aes(x = CB_cover, y = pres.topa) +
geom_point()
ggplot(dat2) +
aes(x = CB_cover, y = soft_cover) +
geom_point()
#Now we explore correlations in data
icol <- sapply(dat2, is.numeric)
pairs(dat2[,icol])
round(cor(dat2[,icol]),2)
install.packages("corrplot")
library(corrplot)
ggplot(dat2) +
aes(x = CB_cover, y = soft_cover) +
geom_point()
#Now we explore correlations in data
icol <- sapply(dat2, is.numeric)
pairs(dat2[,icol])
round(cor(dat2[,icol]),2)
#You can also summarize as a corrplot:
icol <- sapply(dat2, is.numeric)
corrplot(cor(dat2[,icol]))
#Now creating spatial points files - convert spatial data to survey dataframe
kia_crs <- st_crs(logponds)
sdat2 <- st_as_sf(dat2, coords = c("coordx", "coordy"),
crs = kia_crs)
plot(sdat2["pres.topa"])
#To correct CRS to that of logponds:
land <- st_transform(land, kia_crs)
st_crs(land) == kia_crs
#Make a matrix of distances from every sample site to every logpong
distmat <- st_distance(sdat2, logponds)
dim(distmat)
#For each site find the min distance
apply(distmat, 1, min)[1:5]
sdat2$dist_to_logging <- apply(distmat, 1, min)/1000
ggplot(sdat2) +
aes(x = dist_to_logging, y = pres.topa) +
geom_point()
#Save clean dataset
save(sdat2, dat2, land, logponds, kia_crs,
file = "outputs/2021-09-20_cleaned-data.rda")
library(readr)
library(ggplot2)
library(dplyr)
library(sf)
library(corrplot)
setwd("C:/Users/sophi/Documents/UNH_Docs/ModelingClass")
dat <- read_csv("data/JuvUVCSites_with_ReefTypes_16Jun2016.csv")
names(dat)
nrow(dat)
length(unique(dat$site))
range(dat$pres.topa)
ggplot(dat) +
aes(x = secchi, y = pres.topa) +
geom_point() +
stat_smooth()
ggplot(dat) +
aes(x = logged, y = pres.topa) +
geom_boxplot() +
theme_set(theme_classic())
bendat <- read_csv("data/BenthicCoverSurveys.csv")
nrow(bendat)
head(bendat)
range(bendat$cover)
ggplot(bendat) +
aes(x = category,y = cover) +
geom_boxplot() +
theme(axis.text.x = element_text(angle = 90))
#sf allows you to read spatial data
logponds <- st_read("data/Kia_Logging_Ponds/Kia_Logging_Ponds.shp")
names(logponds)
st_crs(logponds)#This checks Coordinate Reference System
land <- st_read("data/LandPoly/LandPoly.shp")
plot(land[1])
#Make a variable for cover of branching corals. Filter ACB or CB
CB_dat <- filter(bendat, code %in% c("ACB", "CB"))
#summarize over two benthic categories
CB_dat <- group_by(CB_dat, site)
CB_dat <- summarize(CB_dat, CB_cover = sum(cover),
n_pts = mean(n_pts))
soft_dat <- bendat %>%
filter(code %in% c("S", "SI")) %>% #Sand or Silt
group_by(site) %>%
summarize(soft_cover = sum(cover),
n_pts = mean(n_pts))
#Now join fish and benthic dataframes
nrow(dat)
dat2 <- left_join(dat, CB_dat, by = "site")
nrow(dat2)
dat2 <- left_join(dat2, soft_dat, by = c("site", "n_pts"))
nrow(dat2)
ggplot(dat2) +
aes(x = logged, y = CB_cover) +
geom_boxplot()
ggplot(dat2) +
aes(x = CB_cover, y = pres.topa) +
geom_point()
ggplot(dat2) +
aes(x = CB_cover, y = soft_cover) +
geom_point()
#Now we explore correlations in data
icol <- sapply(dat2, is.numeric)
pairs(dat2[,icol])
round(cor(dat2[,icol]),2)
#You can also summarize as a corrplot:
icol <- sapply(dat2, is.numeric)
corrplot(cor(dat2[,icol]))
#Now creating spatial points files - convert spatial data to survey dataframe
kia_crs <- st_crs(logponds)
sdat2 <- st_as_sf(dat2, coords = c("coordx", "coordy"),
crs = kia_crs)
plot(sdat2["pres.topa"])
#st_as_sf is the function that converts different data types to simple features. Try ?st_as_sf to see what else it can convert.
#Check that all data has same CRS
st_crs(land) == kia_crs
#To correct CRS to that of logponds:
land <- st_transform(land, kia_crs)
st_crs(land) == kia_crs
#Make a matrix of distances from every sample site to every logpong
distmat <- st_distance(sdat2, logponds)
dim(distmat)
#For each site find the min distance
apply(distmat, 1, min)[1:5]
sdat2$dist_to_logging <- apply(distmat, 1, min)/1000
ggplot(sdat2) +
aes(x = dist_to_logging, y = pres.topa) +
geom_point()
#Save clean dataset MAKE THIS WORK BEFORE MOVING ON
save(sdat2, dat2, land, logponds, kia_crs,
file = "outputs/2021-09-20_cleaned-data.rda")
library(readr)
library(ggplot2)
library(dplyr)
library(sf)
library(corrplot)
setwd("C:/Users/sophi/Documents/UNH_Docs/ModelingClass")
dat <- read_csv("data/JuvUVCSites_with_ReefTypes_16Jun2016.csv")
names(dat)
nrow(dat)
length(unique(dat$site))
range(dat$pres.topa)
ggplot(dat) +
aes(x = secchi, y = pres.topa) +
geom_point() +
stat_smooth()
ggplot(dat) +
aes(x = logged, y = pres.topa) +
geom_boxplot() +
theme_set(theme_classic())
bendat <- read_csv("data/BenthicCoverSurveys.csv")
nrow(bendat)
head(bendat)
range(bendat$cover)
ggplot(bendat) +
aes(x = category,y = cover) +
geom_boxplot() +
theme(axis.text.x = element_text(angle = 90))
#sf allows you to read spatial data
logponds <- st_read("data/Kia_Logging_Ponds/Kia_Logging_Ponds.shp")
names(logponds)
st_crs(logponds)#This checks Coordinate Reference System
land <- st_read("data/LandPoly/LandPoly.shp")
plot(land[1])
#Make a variable for cover of branching corals. Filter ACB or CB
CB_dat <- filter(bendat, code %in% c("ACB", "CB"))
#summarize over two benthic categories
CB_dat <- group_by(CB_dat, site)
CB_dat <- summarize(CB_dat, CB_cover = sum(cover),
n_pts = mean(n_pts))
soft_dat <- bendat %>%
filter(code %in% c("S", "SI")) %>% #Sand or Silt
group_by(site) %>%
summarize(soft_cover = sum(cover),
n_pts = mean(n_pts))
#Now join fish and benthic dataframes
nrow(dat)
dat2 <- left_join(dat, CB_dat, by = "site")
nrow(dat2)
dat2 <- left_join(dat2, soft_dat, by = c("site", "n_pts"))
nrow(dat2)
ggplot(dat2) +
aes(x = logged, y = CB_cover) +
geom_boxplot()
ggplot(dat2) +
aes(x = CB_cover, y = pres.topa) +
geom_point()
ggplot(dat2) +
aes(x = CB_cover, y = soft_cover) +
geom_point()
#Now we explore correlations in data
icol <- sapply(dat2, is.numeric)
pairs(dat2[,icol])
round(cor(dat2[,icol]),2)
#You can also summarize as a corrplot:
icol <- sapply(dat2, is.numeric)
corrplot(cor(dat2[,icol]))
#Now creating spatial points files - convert spatial data to survey dataframe
kia_crs <- st_crs(logponds)
sdat2 <- st_as_sf(dat2, coords = c("coordx", "coordy"),
crs = kia_crs)
plot(sdat2["pres.topa"])
#st_as_sf is the function that converts different data types to simple features. Try ?st_as_sf to see what else it can convert.
#Check that all data has same CRS
st_crs(land) == kia_crs
#To correct CRS to that of logponds:
land <- st_transform(land, kia_crs)
st_crs(land) == kia_crs
#Make a matrix of distances from every sample site to every logpong
distmat <- st_distance(sdat2, logponds)
dim(distmat)
#For each site find the min distance
apply(distmat, 1, min)[1:5]
sdat2$dist_to_logging <- apply(distmat, 1, min)/1000
ggplot(sdat2) +
aes(x = dist_to_logging, y = pres.topa) +
geom_point()
#Save clean dataset MAKE THIS WORK BEFORE MOVING ON
save(sdat2, dat2, land, logponds, kia_crs,
file = "outputs/2021-09-20_cleaned-data.rda")
#Note; how to calcute distances: https://www.seascapemodels.org/rstats/2020/02/08/calculating-distances-in-R.html
rm(list = ls())
library(dplyr)
library(sf)
library()
load("outputs/2021-09-20_cleaned-data.rda")
install.packages("patchwork")
library(patchwork)
g1 <- ggplot(sdat2) +
aes(x = dist_to_logging, y = secchi) +
geom_point() +
stat_smooth()
g1
g2 <- ggplot(sdat2) +
aes(x = dist_to_logging, y = CB_cover) +
geom_point() +
stat_smooth()
g3 <- ggplot(sdat2) +
aes(x = CB_cover, y = pres.topa) +
geom_point() +
stat_smooth()
gall <- g1 + g2 + g3
gall
ggsave("plot1.png", gall, width = 8, height = 3)
install.packages("tmap")
library(tmap)
tm_shape(sdat2) +
tm_symbols(col = "pres.topa", size = 0.2)
tland <- tm_shape(land) +
tm_fill()
tland +
tm_shape(sdat2) +
tm_symbols(col = "pres.topa", size = 0.2) +
tm_scale_bar(position = c("right", "top"))
setwd("C:/Users/sophi/Documents/UNH_Docs/ModelingClass")
install.packages("visreg")
library(visreg)
setwd("C:/Users/sophi/Documents/UNH_Docs/ModelingClass")
glm1_gaus <- glm(pres.topa ~ log10_dist_logging + flow, data = sdat2)
library(dplyr)
library(sf)
library(tmap)
library(patchwork)
load("outputs/2021-09-20_cleaned-data.rda")
setwd("C:/Users/sophi/Documents/UNH_Docs/ModelingClass")
glm1_gaus <- glm(pres.topa ~ log10_dist_logging + flow, data = sdat2)
load("outputs/2021-09-20_cleaned-data.rda")
setwd("C:/Users/sophi/Documents/UNH_Docs/ModelingClass")
g1 <- ggplot(sdat2) +
aes(x = dist_to_logging, y = secchi) +
geom_point() +
stat_smooth()
g1
g2 <- ggplot(sdat2) +
aes(x = dist_to_logging, y = CB_cover) +
geom_point() +
stat_smooth()
g3 <- ggplot(sdat2) +
aes(x = CB_cover, y = pres.topa) +
geom_point() +
stat_smooth()
gall <- g1 + g2 + g3
gall
ggsave("plot1.png", gall, width = 8, height = 3)
tm_shape(sdat2) +
tm_symbols(col = "pres.topa", size = 0.2)
tland <- tm_shape(land) +
tm_fill()
tland +
tm_shape(sdat2) +
tm_symbols(col = "pres.topa", size = 0.2) +
tm_scale_bar(position = c("right", "top"))
# Modeling
library(visreg)
sdat2$log10_dist_logging <- log10(sdat2$dist_to_logging)
glm1_gaus <- glm(pres.topa ~ log10_dist_logging + flow, data = sdat2)
par(mfrow = c(2,2))
plot(glm1_gaus)
glm1_pois <- glm(pres.topa ~ log10_dist_logging + flow, data = sdat2,
family = "poisson")
par(mfrow = c(2,2))
plot(glm1_pois)
install.packages("MASS")
#POSSION NOT GREAT. LOOK AT NEGATIVE BINOMLIA FOR OVERDISPERSION
library(MASS)
glm1_nb <- glm.nb(pres.topa ~ log10_dist_logging + flow, data = sdat2)
par(mfrow = c(2,2))
plot(glm1_nb)
AIC(glm1_gaus, glm1_pois, glm1_nb)
summary(glm1_nb)
sdat2$resid_glm_pois <- resid(glm1_pois)
tland +
tm_shape(sdat2) +
tm_symbols(col = "resid_glm_pois", size = 0.5)
source("data/semivariance.R")
site_distmat <- st_distance(sdat2)/1000
dim(site_distmat)
glm1_pois_semivar <- semivariance(site_distmat, sdat2$resid_glm_pois, ncats = 15)
ggplot(glm1_pois_semivar) +
aes(x = distances, y = semivar) +
geom_point() +
stat_smooth()
library(ggplot2)
ggplot(glm1_pois_semivar) +
aes(x = distances, y = semivar) +
geom_point() +
stat_smooth()
glm_nb_plots <- plot_spatial_AC(sdat2, glm1_nb, site_distmat)
tland + glm_nb_plots[[1]]
glm_nb_plots[[2]]
#library(visreg)
visreg(glm1_nb)
install.packages("nlme")
library(nlme)
sdat2$sqrt_topa <- sqrt(sdat2$pres.topa)
m1_gls <- gls(sqrt_topa ~ log10_dist_logging + flow,
data = sdat2)
sdat2$x <- st_coordinates(sdat2)[,1]
library(nlme)
sdat2$sqrt_topa <- sqrt(sdat2$pres.topa)
m1_gls <- gls(sqrt_topa ~ log10_dist_logging + flow,
data = sdat2)
sdat2$x <- st_coordinates(sdat2)[,1]
#library(visreg)
visreg(glm1_nb)
library(visreg)
visreg(glm1_nb)
visreg(glm1_nb)
library(dplyr)
library(sf)
library(tmap)
library(ggplot2)
library(patchwork)
load("outputs/2021-09-20_cleaned-data.rda")
setwd("C:/Users/sophi/Documents/UNH_Docs/ModelingClass")
g1 <- ggplot(sdat2) +
aes(x = dist_to_logging, y = secchi) +
geom_point() +
stat_smooth()
g1
g2 <- ggplot(sdat2) +
aes(x = dist_to_logging, y = CB_cover) +
geom_point() +
stat_smooth()
g3 <- ggplot(sdat2) +
aes(x = CB_cover, y = pres.topa) +
geom_point() +
stat_smooth()
gall <- g1 + g2 + g3
gall
ggsave("plot1.png", gall, width = 8, height = 3)
tm_shape(sdat2) +
tm_symbols(col = "pres.topa", size = 0.2)
tland <- tm_shape(land) +
tm_fill()
tland +
tm_shape(sdat2) +
tm_symbols(col = "pres.topa", size = 0.2) +
tm_scale_bar(position = c("right", "top"))
# Modeling
library(visreg)
sdat2$log10_dist_logging <- log10(sdat2$dist_to_logging)
glm1_gaus <- glm(pres.topa ~ log10_dist_logging + flow, data = sdat2)
par(mfrow = c(2,2))
plot(glm1_gaus)
#NORMAL DISTRIBUTION NOT APPROPORATE. LOOK AT POISSON
glm1_pois <- glm(pres.topa ~ log10_dist_logging + flow, data = sdat2,
family = "poisson")
par(mfrow = c(2,2))
plot(glm1_pois)
#POSSION NOT GREAT. LOOK AT NEGATIVE BINOMLIA FOR OVERDISPERSION
library(MASS)
glm1_nb <- glm.nb(pres.topa ~ log10_dist_logging + flow, data = sdat2)
par(mfrow = c(2,2))
plot(glm1_nb)
AIC(glm1_gaus, glm1_pois, glm1_nb)
summary(glm1_nb)
sdat2$resid_glm_pois <- resid(glm1_pois)
tland +
tm_shape(sdat2) +
tm_symbols(col = "resid_glm_pois", size = 0.5)
source("data/semivariance.R")
site_distmat <- st_distance(sdat2)/1000
dim(site_distmat)
glm1_pois_semivar <- semivariance(site_distmat, sdat2$resid_glm_pois, ncats = 15)
ggplot(glm1_pois_semivar) +
aes(x = distances, y = semivar) +
geom_point() +
stat_smooth()
glm_nb_plots <- plot_spatial_AC(sdat2, glm1_nb, site_distmat)
tland + glm_nb_plots[[1]]
glm_nb_plots[[2]]
library(visreg)
visreg(glm1_nb)
library(nlme)
sdat2$sqrt_topa <- sqrt(sdat2$pres.topa)
m1_gls <- gls(sqrt_topa ~ log10_dist_logging + flow,
data = sdat2)
sdat2$x <- st_coordinates(sdat2)[,1]
sdat2$y <- st_coordinates(sdat2)[,2]
cs1Sph <- corSpher(1, form = ~x + y)
m2_gls <- gls(sqrt_topa ~ log10_dist_logging + flow,
data = sdat2,
correlation = cs1Sph)
plot(m2_gls)
summary(m2_gls)
gls_plots <- plot_spatial_AC(sdat2, m2_gls, site_distmat)
gls_plots[[2]]
install.packages("mgcv")
library(mgcv)
m1_gam <- gam(pres.topa ~ s(log10_dist_logging) + flow,
family = "nb",
data = sdat2)
visreg(m1_gam)
library(visreg)
visreg(m1_gam)
m1_gam_plots <- plot_spatial_AC(sdat2, m1_gam, site_distmat)
library(dplyr)
library(sf)
library(tmap)
library(ggplot2)
library(patchwork)
library(nlme)
library(MASS)
library(nlme)
library(mgcv)
m1_gam_plots <- plot_spatial_AC(sdat2, m1_gam, site_distmat)
tland + m1_gam_plots[[1]]
visreg(m1_gam)
m1_gam_plots <- plot_spatial_AC(sdat2, m1_gam, site_distmat)
tland + m1_gam_plots[[1]]
m1_gam_plots[[2]]
#GAMS with spatial covariates
m2_gam <- gam(pres.topa ~ s(x, y, bs = "gp"),
family = "nb",
data = sdat2)
plot(m2_gam, se = FALSE)
m2_gam_plots <- plot_spatial_AC(sdat2, m2_gam, site_distmat)
tland + m2_gam_plots[[1]]
m2_gam_plots[[2]]
m3_gam <- gam(pres.topa ~ s(log10_dist_logging) +
s(x, y, bs = "gp"),
family = "poisson",
data = sdat2)
plot(m3_gam)
concurvity(m3_gam, full = FALSE)
